
https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus
Lambda C
============

본 첼린지는 람다대수의 기본적인 개념들을 프로그래밍 언어를 이용해 직접 실습해 본다. 람다대수가 무엇인지, 왜 중요한지 이해하기 위해서는 약간의 역사공부를 해야 한다.

## 역사공부

20세기 초, 다비트 힐베르트는 '힐베르트 프로그램'이라는 구상을 한다. 수학을 형식화해 그 형식체계가 무모순임을 유한적 방법으로 증명할 수 있다"는 것이다. 이는 "산술의 무모순성 증명"이라는 이름으로 힐베르트의 23가지 문제에도 2번째로 포함되어있다. [1]

그는 저서 "기하학의 기초"에서 산술적 무모순성을 가정했을때 기하학이 무모순임을 증명할 수 있었다. 그리고 이제 남은 것은 현 수학의 형식체계의 무모순성 증명뿐일 터였다.
그러나 20대 청년 괴델이 불완전성 정리을 들고 나와 "현 수학(을 나타내는 형식체계)의 무모순성은 메타수학 없이는 증명할 수 없다"는 것을 증명하게 된다.

여기서 '형식체계'란 모종의 규칙들을 이용해 공리로부터 정리를 연역하는 체계를 의미한다. 쉽게 말해 우리가 평소에 부르는 수학과 수학적 증명을 나타내는 말이다. 다만 우리는 형식체계를 연구한 많은 수학자들 덕분에 연역적 증명체계와 그 공리들이 당연한 것이라고 (as granted) 믿고 넘어갈 수 있는 것이다.

형식체계는 자연어로 표현될 수도 있지만 기호가 빈번히 사용된다. 자연언어는 종종 모호(ambiguity)하고 애매(vague)하기 때문이다.[2] 사실 영어나 한국어로 표현해도 알파벳이나 한글이라는 기호로 표현하는 것이지만, 애매성과 모호성을 제한 새로운 표현체계를 이용한다는데 그 의의가 있다. 또한, 그러한 기호체계를 사용해서 서술한다면 형식체계를 증명하고 계산하는일이 쉬워지기도 한다.

형식체계를 기호만으로 표현하는 방법은 한가지가 아니다. 그 중 대표적인것이 '괴델 수'이다. 쿠르트 괴델이 불완전성 정리를 증명하는 과정에서 사용한 시스템으로, 형식체계에서 기호로 표현되는 명제를 자연수로 번역하는 방법이다. 괴델은 임의의 형식체계와 괴델 수의 isomorphism이 존재한다는 것을 보이고, 자연수에 대한 조작을 함으로써 목적을 달성할 수 있었다. [4]

힌편, 형식체계에서의 증명은 어떤 의미에선 알고리즘으로 볼 수도 있다. 완전히 기호만을 사용해 서술된 명제와 증명은 결국 "일련의 기호들(가정)을 이렇게, 그리고 또 저렇게 조작하면 결과(결론)가 나온다"는 서술이기 때문이다. 때문에 형식체계에 대한 연구는 알고리즘의 정의로 넘어오게 된다.

무엇이 알고리즘인지 정의하는 첫 번째 시도는 알론조 처치의 학위논문에서 나왔다. 그는 '람다대수'라는 체계를 고안해 우리가 아는 모든 알고리즘은 이것으로 증명할 수 있다고 가정했다. 하지만 그가 정의한 대수체계는 너무나 단순해서 컴퓨터 과학의 수많은 복잡다단한 알고리즘들을 다 표현할 수 없을 것 같았다. 마침 지나가던 괴델이 처치의 정의를 보고 너무 제한적이라고 (람다대수로 표현할 수 없는 알고리즘이 있을 것이라고) 생각해 직접 새로운 정의를 만들기로 한다. [5]

괴델은 그 후 Recursive functions라는 정의를 만들어냈다. 처음엔 자신의 정의가 람다대수를 포함하는 더 일반적인 정의일 것이라 생각했으나 후에 람다대수와 동치인 시스템이라는것이 밝혀졌다. 처치의 시스템을 비판했던 괴델은 자신의 정의에도 뭔가 실수가 있어 보편적이지 않은 시스템이 되었다고 생각했을 것이다. [5]

알고리즘의 세 번째 정의는 우리가 모두 잘 아는 앨런 튜링에서 나온다. 튜링은 '계산 가능한 문제'의 정의를 '튜링머신이 풀 수 있는 문제'라고 정의했다. 튜링머신은 테이프, 테이프 위의 장치, 테이프 R/W 규칙으로 이루어진, 다분히 기계적으로 보이는 구상이다. 튜링이 앞선 두 정의를 알았는지는 모르지만, 순수 수학적으로 정의된 앞선 두 체계와는 동떨어져 보인다. 그러나 나중에 밝혀지길 튜링머신과 괴델, 처치의 정의는 모두 동치라는것이 증명되었다. [5]

이쯤 되면 수학자들은 믿기 싫어도 믿을 수밖에 없게 된다. 독자적으로 개발된 3개의 시스템이 사실은 모두 동치였다는 것은, 처치와 괴델, 튜링이 각자의 시스템을 '만들어 낸 것'이 아니라 '발견해낸 것'임을 강하게 시사하는것처럼 보인다. 그게 진짜인지는 모라도 어쨌든 수학자들 그들의 시스템으로 계산가능성(computability)이란 개념을 정의하기로 합의를 보게 된다. 그 뒤에 DFA, NFA, Combinatory logic 등등이 동치임이 밝혀졌다.


## 람다대수

본 항목은 람다대수의 기본적인 설명을 담고있다. 본인이 람다대수의 전문가가 아니기 때문에 간단히 위키피디아 페이지를 훑어보는게 본 항목을 읽는 것보다 도움일 될지도 모른다. 너무 많이 읽으면 실습부분을 스포당하니 조심해야 한다. 도입부분만 읽어보자.

### 문법 (syntax)

람다대수는 아주 간단하다. 문법 (표현식)을 BNF로 나타내면 이렇게 된다.
```
L, M, N ::= x | (λx. N) | (L M)
```

L, M, N을 임의의 람다식이라 할 때, 람다식은 다음 세 가지 형태 중 하나이다.
1. 변수(x):
  밑에 나오는 '추상화'의 인자로써 도입될 수 있다.
2. 추상화(λx. N):
  변수 x를 인자로 받아 함수 몸체인 N을 실행하는 함수라고 생각할 수 있다.
3. 적용(L M):
  L이 함수, M을 인자로 하여 함수적용을 하는 것이라 생각할 수 있다.

위의 리스트에서 중요한 것은 설명이 아니라 문법, 표현구조이다. 각 표현구조의 설명은 단지 semantic을 이해하는 힌트가 되도록 붙인 것이다. 람다식 그 자체로는 아무런 의미가 없다. 그저 문법에 맞게 기호들이 조함되어 있을 뿐이다.

일단 문법에 익숙해지기 위해 예시를 들어보겠다. 람다식의 밑에 붙인 설명은 식의 이해를 돕기 위해 AST(Abstract Syntax Tree)를 표현한 것이다.

1. `(λz. z)`:
  추상화(z, 변수(z))
2. `(w x)`:
  적용 (변수(w), 변수(x))
3. `(λz. (x z))`:
  추상화(z, 적용(변수(x), 변수(z)))
  _이 밑으로는 변수()를 생략한다. 너무 길고 복잡해지니까._
4. `(λx. ((λy. x) y))`:
  추상화(x, 적용(추상화(y, x), y)))
5. `((w x) y) z`:
  적용(적용(적용(w, x), y), z)
6. `(λc. (z (λz. x (y z))))`:
  추상화(c, 적용(z, 추상화(z, 적용(x, 적용(y, z))))

원래 람다식은 추상화와 적용을 사용할 때 괄호를 쓰는것이 기본이다. 하지만 그렇게 쓰면 식이 너무 더러워지므로 모호하지 않은 선에서 괄호를 생략해서 쓸 수도 있다. 대략의 규칙은 이러하다.
1. 추상화는 가능한 한 길게, 문장의 끝이나 닫는괄호까지 포함한다. `λx. y z`는 `(λx. y) z`가 아니라 `λx. (y z)`으로 해석한다.
2. 적용은 맨 왼쪽부터 한다. `w x y z`는 `((w x) y) z`으로 해석한다.
3. 겹친 괄호는 하나로 만든다. `((X))` => `(X)`
4. 맨 바깥 괄호는 생략한다. `(λz. z)` => `λz. z`

그에 따라 앞선 예시 리스트의 람다식들에서 괄호를 없애면 다음과 같아진다.
1. `λz. z`
2. `w x`
3. `λz. x z`
4. `λx. (λy. x) y`
5. `w x y z`
6. `λc. z λz. x (y z)`


### 의미론 (semantic)

이제 람다식에 의미를 부여할 차례이다. 람다식을 어떻게 조작할 수 있는지 정의하면 그에 따라 의미(semantic)가 생성된다. [6] [7] 문법 설명에서 간단히 언급했듯이, 람다대수의 조작규칙들은 수학(혹은 프로그래밍)에서의 함수정의/함수적용과 유사한 (거의 같다) 의미를 가져온다. 앞으로 설명에서는 추상화를 함수, 적용을 함수적용, 변수를 함수의 지역변수에 비유하며 설명하겠다.

람다대수에는 기본적으로 두 가지 규칙이 있는데 둘 다 추상화(함수)와 관련이 있다.

* α-변환 (λx.M[x]) → (λy.M[y])
  변수 이름 바꾸기이다. 이때 다른 추상화식의 지역변수가 같은 이름일 경우 건드리지 않는다. 증명할 때 말고는 별로 쓸 일이 없다.
* β-축약 ((λx.M) E) → (M[x:=E])
  함수 적용을 수행한다. 인자를 x로 받는 함수에 인자로 E를 주었을 때, 그 몸체의 모든 x를 E로 바꾸는 것이다. 이때 다른 추상화식의 지역변수가 같은 이름일 경우 건드리지 않는다.

1.
```
   (λy. x y) z
  =β=>  x z
```
2.
```
       (λx. x ((λx. x y) (λz. z))) (λk. k l)
  =β=> (λx. x     ((λz. z) y))     (λk. k l)
  =β=> (λx. x           y)         (λk. k l)
  =β=>      (λk. k l)   y
  =β=>           y l
```

이렇게 의미를 부여하게 되면 람다식은 일변수 함수밖에는 표현할 수가 없게 된다. 하지만 이게 큰 문제가 되진 않는다. 모든 다변수함수는 일변수함수로 표현할 수 있기 때문이다. 예를 들어 인자 2개(x, y)를 받는 추상화는 이렇게 표현할 수 있다.
```
λx. λy. M
```

이 식에 a와 b를 적용하면
```
(λx. λy. M) a b = ((λx. (λy. M)) a) b
  =β=> (λy. M[x:=a]) b =β=> M[x:=a][y:=b]
```
이렇게 2변수 함수를 적용한 것과 똑같은 효과가 나온다. 'λx. λy. M' 식의 의미는 "변수 하나(x)를 인자로 받아 '변수 하나(y)를 인자로 받는 함수'를 반환하는 함수"로 생각할 수 있다. 이를 논리학자 Haskell Curry의 이름을 따서 Currying이라고 부른다.

## 실습

람다대수는 굉장히 간단한 시스템이지만 모든 계산가능한 문제를 서술할 수 있다. 피보나치 수열, 유클리드의 gcd 알고리즘, backpack문제 등 무엇이든 가능하다. 실제로 컴퓨터를 이용해 증명된 첫 수학문제라는 타이틀로 유명한 4색문제는, 람다대수를 바탕으로 설계된 시스템을 이용해 증명되었다.

가진게 함수, 변수, 적용 밖에 없는데 어떻게 그런 복잡한 문제를 서술/해결하는가. 그 해결은 람다대수의 창시자인 알론조 처치의 천재성에 있다. 앞으로의 실습에서 그의 정의를 따라 몇가지 간단한 개념들을 람다식으로 정의해 볼 것이다. 하지만 람다식으로 써놓기만하면 맞게 했는지 알수가 없으니 practical한 프로그래밍 언어로 실제 구현을 해 보도록하자. 꼭 함수형 언어가 아니더라도 최근의 웬만한 프로그래밍 언어들은 First-class function[8]을 지원하기 때문에 적당한 언어를 고를 수 있다.

여기에서는 파이선3을 이용한다. 파이썬의 함수 정의를 람다 대수의 추상화, 함수 호출을 β-축약으로 사용할 것이다.

_주의: 파이썬 코드를 짤 때 람다식을 번역하여 적어야 한다는 사실을 명심하라. 파이썬의 여러 기능을 사용하면 문제를 아주 간단히 풀 수 있으나 그것은 틀린 코드이다. 먼저 람다식을 작성하고 번역하는 작업을 하지는 않더라도, 람다대수의 범위에서 벗어나는 기능을 사용하지 않도록 해야한다._

### 자연수

알론조 처치는 람다대수에서 자연수 n을 '함수 f를 인자로 받아 f를 n번 반복 적용하는 함수 fn을 리턴하는' 함수로 표현할 수 있음을 발견했다. 예를들어 자연수 1과 3을 one, three라는 함수로 나타낸다고 하면 다음과 같이 작동할 것이다. 구현은 신경쓰지 말고 one과 three가 기능적으로 어떻게 행동하는지 이해해보자.
```python
def one(f):
  pass

def three(f):
  pass

def append_pip(str):
  return str + " pip"

one_pip = one(append_pip)
three_pip = three(append_pip)
one_pip("counting..")   #=> "counting.. pip"
three_pip("counting..") #=> "counting.. pip pip pip"
```
_여기서 `append_pip`이란 함수를 람다식으로 어떻게 표현할지 걱정하는 사람도 있을것  같다. 아쉽게도 `append_pip`을 포함해 앞으로 나올 도우미 함수들은 (적어도 간단한 방법으로는) 람다표현으로 바꿀 수 없다. 그런 함수들은 주어진 개념이나 람다식을 설명/확인/검증하기 위한 목적으로 사용되기 때문에 람다와 직접적인 연관이 없는것이다. 여기서는 `three`가 함수를 인자로 받아 세 번 연속적용하는 함수를 리턴한다는 것을 이해하면 된다. 다만, 곧 보겠지만 `one`과 `three`는 람다식으로 환원될 수 있도록 구현된다._

자연수를 '함수의 반복적용'으로 정의한다는 것이 무슨 뜻일까. "자연수는 함수의 인자가 되는 것이지 함수 자체가 자연수가 될 수는 없지 않은가" 하고 생각하고 있을지도 모르겠다. 대상이 어떻게 표현/정의되었든 자연수라는 의미를 부여하는 것은 대상의 조작규칙이다. 처치식 자연수 정의가 교환법칙 결합법칙 등 자연수의 기본적인 성질을 만족하고 자연수에 행할 수 있는 조작규칙들이 람다대수에도 존재한다면 그것을 자연수라고 부름에 어려울 것이 없다. 설령 그것이 함수일지라도.

위 예제의 함수 적용 부분을 조금 더 간추리면 이렇게도 쓸 수 있다.
```python
three(append_pip)("counting..") #=> "counting.. pip pip pip"
```
괄호를 두번 쓰는것이 어색해보인다. 귀찮으니 그냥 한번만 쓸 수 있도록 three의 정의를 바꿔보면 어떨까.
```python
def three_(f, x):
  return three(f)(x)
three_(append_pip, "counting..") #=> "counting.. pip pip pip"
```
three_는 처치의 정의와 맞지 않는것 같아 보인다. 처치의 정의를 따르면 three는 unary 함수를 인자로 받아 unary 함수를 리턴해야 하는것 아닌가. 하지만 괜찮다. currying을 사용하면 다변수 함수나 일변수 함수나 같은것이기 때문이다. 인수를 따로따로 받느냐 처음에 모아서 받느냐의 차이일 뿐이다. 정 걱정된다면 다음 도우미 함수를 사용할 수도 있다.
```python
def curry2(f):
  return lambda a: lambda b: f(a, b)
_three = curry(three_)
_three(append_pip)("counting..") #=> "counting.. pip pip pip"
```
`curry2` 함수는 binary함수에 currying을 해서 일변수 함수를 리턴하는 일변수 함수로 바꿔준다. `_three`는 `three`와 똑같이 사용할 수 있다.

설명은 이만하고 실제 구현을 만들어보자.
```python
def one(f, x):
  return f(x)
def two(f, x):
  return f(f(x))
def three(f, x):
  return f(f(f(x)))
```
혹은 일변수 함수로 이렇게 정의할 수도 있다.
```python
def one(f):
  return lambda x: f(x)
def two(f):
  return lambda x: f(f(x))
def three(f):
  return lambda x: f(f(f(x)))
```
하지만 이렇게 쓰면 이후의 예제들을 실행해 볼 때 괄호들을 추가해 줘야한다.

이제 위의 append_pip 예제들을 돌려보면 예상한 답이 나온다. 하지만 답이 맞는지 확인할 때마다 pip을 세어보는건 귀찮으니 처치식 자연수를 python int로 바꿔주는 도우미 함수를 만드는것이 좋겠다.
```python
def c2n(n):
  return n(lambda z: z+1, 0)
```
혹은 일변수 함수로 정의했을 경우에는
```python
def c2n(n):
  return n(lambda z: z+1)(0)
```
_매우 기계적인 변환이므로 앞으로 일변수함수 버전은 생략한다._

c2n에다가 one, two, three를 넣어보면 각각 1, 2, 3을 반환한다.

참고: 이 부분이 본 첼린지의 정수이다. 그냥 람다대수를 공부하고 책의 연습문제를 풀어보는 것이라면 굳이 프로그래밍 언어를 사용하지 않아도 상관없다. 하지만 그렇게 했을때 본인이 적은 람다식이 제대론 된 것인지 확인해보는 작업은 실수하기 쉽고 지루한 일이다. 본 챌린지에서는 여러분이 정의한 람다식이 정말 의도에 맞는지 0.1초만에 확인할 수 있다.

처치식 자연수를 구현할 때마다 직접 함수를 적지 않고, 페아노 공리계에서 하는 것처럼 successor를 통해 정의할 수도 있다.
```python
def zero(f, x):
  return x

def s(n):
  return lambda f, x : f(n(f,x))
```
가령 one은 s(zero)와 같고 two는 s(s(zero)), s(one)과 같다. 실제로 실행해서 제대로 작동하는지 확인해보자.
```python
c2n(zero)    #=> 0
c2n(s(zero)) #=> 1
four = s(three)
c2n(four)    #=> 4
c2n(s(s(s(s(s(s(s(s(s(s(s(zero)))))))))))) #=> 11
```
이렇게 정의하면 자연수의 속성을 증명하거나 정리를 작성할때 굉장히 편리해진다. 뿐만아니라 기존 수학에서 사용했던 많은 증명들을 거의 그대로 가져와서 사용할 수 있게된다. 하지만 본 챌린지에서 증명부분은 다루지 않는다.

이제 덧셈을 정의해 보자.
```python
def add(n, m):
  pass
c2n(add(one, zero))  #=> 1
c2n(add(zero, zero)) #=> 0
five = add(three, two)
c2n(five) #=> 5
```

하는김에 곱셈과 자승도 정의하자. curry2함수가 필요할지도 모른다.
```python
def mult(n, m):
  pass
c2n(mult(zero, one))  #=> 0
c2n(mult(one, three)) #=> 3
six = mult(three, two)
c2n(six) #=> 6

def exp(n, m):
  pass
c2n(exp(zero, one))  #=> 0
c2n(exp(two, zero))  #=> 1
c2n(exp(three, one)) #=> 3
c2n(exp(two, three)) #=> 8
```

아쉽게도 뺄셈은 아직 정의할 수 없다. 결과값이 음수가 되는 경우 자연수로는 표기할 수 없기 때문이다. [9] 아쉬움을 뒤로하고 마지막으로 자연수 n을 받아서 처치식 자연수를 반환하는 컨버터를 만들어보자. 이 함수는 람다식으로 환원될 수도 없고 그럴 필요도 없다.
```python
def n2c(n):
  pass
```

앞에서 한 함수 정의들은 (도우미 함수를 제외하고) 모두 람다식으로 변환할 수 있다.
```
zero := λf. λx. x
one  := λf. λx. f x
two  := λf. λx. f (f x)
s    := λn. λf. λx. f (n x)
```

혹시 심심하다면 직접 구현한 함수들도 번역해보자
```
add  :=
mult :=
exp  :=
```

### 불리언

람다식으로 데이터 스트럭처를 표현하는것은 주로 그 대상의 사용을 함수로써 나타내는 것이다. 불리언 타입은 어디에 사용할까? 단순히 두 가지 상태를 나타내기 위해서라면 enum 타입 내지는 정수 (0 또는 1)을 사용하면 된다. 오직 불리언만 가능하고 불리언의 목적이기도 한 작업은 if-else의 브랜칭이다. if의 조건절에는 꼭 불리언 표현식이 들어가야 한다. 브랜칭에 정수를 사용하는 C나 어셈블리에서도 결국은 레지스터의 isZero?를 검사한 후 점프를 한다. 파이썬에서는 리스트나 해쉬따위를 조건절에 사용할수 있지만 그저 파이썬이 isEmpty?를 대신 호출해주는것에 불과하다. 브랜칭을 위해서는 근본적으로 불리언이 필요하다.

그렇다면 브랜칭을 함수로 어떻게 나타낼까. 부작용이 없는 연산만 사용한다면 if-else 구문은 삼항연산자를 사용하는것과 같다. 삼항 연산자는 람다식으로 이렇게 표현할 수 있다.
true  := λx. λy. x
false := λx. λy. y
불리언 값은 인자 2개를 받는 함수인데 True는 첫번째 인자를, False는 두 번째 인자를 반환한다. x가 불리언 타입이라고 한다면 x a b 는 x가 true일때 a, false일때 b가 된다.

파이썬 코드로 작성하면 다음과 같다.
```python
def true(x, y):
  return x

def false(x, y):
  return y
```

테스트하는데 도움이 될 법한 도우미 함수도 정의하자.
```python
# 처치식 불리언을 파이썬 불리언으로 변환한다.
def c2b(b):
  return b(True,False)

def b2s(b):
  if b:
    return "T"
  else:
    return "F"

# 주어진 unary 함수의 진리표를 출력한다.
def check_b(f):
  print(f'T: {b2s(f(true))}')
  print(f'F: {b2s(f(false))}')

# 주어진 binary 함수의 진리표를 출력한다.
def check_bb(f):
  print(f'T T: {b2s(f(true, true))}')
  print(f'T F: {b2s(f(true, false))}')
  print(f'F T: {b2s(f(false, true))}')
  print(f'F F: {b2s(f(false, false))}')
```

이제 다음의 연산들을 구현하라.
그리고 check_b+ 함수들을 사용해 옳은 답이 나오는지 확인하라.
```python
def neg(b):
  pass

def conj(b1, b2):
  pass

def disj(b1, b2):
  pass

def xand(b1, b2):
  pass

def xorr(b1, b2):
  pass
```

### 다시 자연수 (optional)

앞서 대상의 사용을 함수로써 나타냄으로써 데이터 스트럭쳐를 람다식으로 표현할 수 있다고 언급했다. 그렇다면 자연수의 경우는 어떨까. 자연수의 사용은 반복적용이라고 할 수 있을까? 우리가 아는 자연수는 반복보다는 세는것(counting)에 가깝다. [10]
TODO

### 튜플

튜플 혹은 Pair라고 불리는 데이터 구조는 수학에서 순서쌍이라고 번역되는 그것이다. 두 데이터를 묶어서 하나의 데이터처럼 취급할 수 있다. 튜플처럼 단순히 두 쌍을 모아둔것에 무슨 사용이 있을까 싶지만, 잘 생각해보면 튜플의 사용은 '선택'임을 알 수 있다. 튜플을 가지고 무엇인가 하려면 두 원소중에 앞의 것을 쓸 건지(fst) 뒤의 것을 쓸 것인지(snd) 결정해야 하기 때문이다. 이를 염두에 두고 람다식 튜플을 정의해 보자.
```python
# 두 데이터를 받아 튜플을 만든다. constructor의 줄임말이다.
def con(x, y):
  pass

# 튜플을 받아 앞의 원소를 리턴한다. first의 줄임말이다.
def fst(t):
  pass

# 튜플을 받아 뒤의 원소를 리턴한다. second의 줄임말이다.
def snd(t):
  pass
```

다음 함수를 사용하면 람다식 튜플을 [11] 파이썬 튜플로 변환할 수 있다.
```python
def c2p(p):
  return fst(p), snd(p)
```

본인의 구현이 아래의 테스트를 통화하는지 확인하라.
```python
c2p(con(1,3)) #=> (1, 3)
pair = con(one,three)
c2n(fst(pair)) #=> 1
c2n(snd(pair)) #=> 3
```

### 정수

현대 수학에서는 정수를 자연수의 페어(튜플)로 정의한다. 임의의 자연수 a, b에 대해서 튜플 (a, b)는 (a - b)인 정수를 표현한다. 예를 들어 두 튜플 (3, 4)와 (5, 6)는 모두 우리가 평소에 -1이라고 쓰는 정수를 나타낸다. [12] 이렇게 했을 때 덧셈과 뺄셈은 이렇게 정의된다.
```
(a, b) + (c, d) = (a+c, b+d)
(a, b) - (c, d) = (a+d, b+c)
```
a,b,c,d가 두 자연수임을 기억하라. 덧셈을 해도, 뺄셈을 해도 튜플 안의 숫자는 계속 커지기만 한다. 하지만 두 원소의 차는 우리가 예상하는 값을 가지게 된다.
```
(3, 4) + (8, 1) = (11, 5)
( -1 ) + (  7 ) = (  6  )

(3, 4) - (8, 1) = (4, 12)
( -1 ) - (  7 ) = ( - 8 )
```

이런 구상을 람다식으로 나타내어보자. 앞서 정의한 튜플과 자연수를 이용하면 어렵지 않게 정의할 수 있다.
```python
def add_i(i, j):
  pass

def minus_i(i, j):
  pass
```
그리고 어떻게 하는지 설명은 안했지만 곱셈도 정의해보자. 조금만 고민해보면 그리 어렵지 않다.
```python
def mult_i(i, j):
  pass
```

아래의 도우미 함수들을 이용해 구현을 테스트 해 보라.
```python
# 람다식 정수를 파이썬 정수로 바꾼다.
def c2i(i):
    return c2n(fst(i)) - c2n(snd(i))

# 처치식 자연수를 람다식 정수로 바꾼다.
def n2i(n):
    return con(n, zero)

n_one_ = minus(n2i(zero), n2i(one))
n_one = con(two, three)
n_two = add_i(n_one_, n_one)
n_three = add_i(n_one, n_two)
n_six = mult_i(n_three, n2i(two))

c2i(n_one_) #=> -1
c2i(n_one)  #=> -1
c2i(n_two)  #=> -2
c2i(n_six)  #=> -6
```

exp와 div는 아직 정의할 수 없다. 결과값이 유리수가 나올 수 있기 때문이다. 유리수도 정수와 유사한 방법으로 (정수의 튜플을 쓰면 된다) 정의할 수 있지만, 그걸 람다식으로 직접 구현하는것은 머리보다는 손이 힘든 작업일 뿐이다. 그래서 본 챌린지에서는 하지 않는다.

유리수를 넘어 무리수는 ('실수에서 유리수가 아닌 수'라고 정의하는게 아니라) 극한을 사용하여 정의한다. 하지만 극한을 사용하기 위해서는  ∀이나 ∃뿐만 아니라 크기비교가 필요하기 때문에 아직은 할 수 없다.

### 리스트

이제 비로소 데이터 스트럭쳐다운 뭔가를 정의할 차례다. 리스트란 c에서의 어레이와 비슷한 쓰임새를 가진 데이터이다. 순서대로 늘어선 데이터들을 묶어서 취급한다. 어레이는 c언어에선 연속된 메모리, 자바에서는 연속된 레퍼런스로 구현되지만 람다대수나 함수형 프로그래밍 언어에서는 그렇게 할 수가 없다. 원소 갯수가 정해져있다면 튜플처럼 구현하면 되지만 (트리플? 쿼드플?) 리스트는 길이가 정해져 있지 않다. 임의 갯수의 원소를 순서로 담을 수 있다는것이 리스트의 의의니까 말이다.

리스트를 정의하는 방법은 한가지가 아니다. 마치 자연수가 그러했던 것처럼 리스트의 사용을 무엇으로 보는가에 따라 다른 정의를 만들 수 있다. 그중에서 가장 보편적으로 합의된 리스트의 사용은 'fold'이다. fold란 리스트의 모든 원소를 차곡차곡 겹쳐(접어)서 하나의 값으로 만드는 작업을 의미한다. 유명한 병렬컴퓨팅 프레임워크인 하둡의 MapReduce에서 reduce가 바로 fold이다. 파이썬에서는 reduce라고 불린다.

fold의 가장 간단한 예시는 덧셈이다. 예시를 설명하기 위해 잠시 파이썬 리스트를 이용하겠다.
```python
from functools import reduce
xs = [1,2,3,4]
reduce(lambda a,b: a+b, xs, 100) #=> 110
```
위의 reduce는 다음을 계산한다.
```python
(((100 + 1) + 2) + 3) + 4 #=> 110
```

reduce는 맨 처음 값과 리스트의 첫 값을 계산하고, 그 결과를 리스트의 두번째 값과 계산하고... 이를 리스트 끝까지 반복한 후 결과를 리턴한다. 사실 fold에는 두 가지 종류가 있는데 reduce처럼 리스트의 왼쪽부터 계산하는것을 foldl (left) 오른쪽부터 계산하는것을 foldr (right)라고 한다. 덧셈이나 곱셈같은 commutative한 연산에서는 차이가 없지만 나눗셈처럼 nocommutative한 연산에서는 다른 값을 낸다.
```python
# foldl과 foldr이 아직 정의되지 않았으므로 아직 실행할 수는 없다.
foldl(lambda acc,x: acc/x, [1,2,3,4], 120) #=> 5
foldr(lambda x,acc: x/acc, [1,2,3,4], 120) #=> 45
```
위의 예제가 어떻게 작동하는지 직접 계산해보자. foldr은 주어진 함수에게 인수를 반대로 준다는 점에 유의하라. (acc에 계산값이, x에 리스트의 원소가 주어진다)

fold에서 계산 결과 값 (맨 처음에 주는 seed값, 매번 인자로 준 함수가 리턴하는 값, 그리고 결과적으로 fold가 리턴하는 값)을 어큐뮬레이터(accumulator)라고 부른다. 지금까지의 계산 값을 축적하고 있기 때문이다. 그래서 위 예제 람다함수의 인자에 acc라는 이름을 붙였다.

fold에 익숙하지 않은 사람은 람다식 리스트를 구현하기 전에 fold를 제대로 이해하는것이 중요하다. foldl을 (반복문을 쓰지 말고) 재귀함수로 구현해보자. 인수로 주어진 리스트는 마음대로 mutation-safe 하다고 가정하라. (함수 안에서 값을 수정해도 호출부에서 신경쓰지 않는다)

```python
def foldl(f, ls, seed):
  pass

foldl(lambda a,b: b/a, [1,2,3,4], 120) #=> 5
foldl(lambda a,b: b/a, [4,3,2,1], 120) #=> 45
```

foldl만 사용했는데도 앞의 foldr 예시와 같은 값이 나온다. 사실 두 함수는 어느 하나도 다른 하나를 구현할 수 있다. 우리는 foldl을 먼저 구현했으니 그걸 이용해 foldr을 구현해보라 (가능함을 확인하는 것 뿐이니 효율성에 신경쓰지 않아도 된다)
```python
def foldr(f, ls, seed):
  pass
foldr(lambda a,b: b/a, [1,2,3,4], 120) #=> 320
```

이제 본론으로 돌아가서 리스트를 구현해보자. 리스트는 두 가지 방법으로 만들 수 있다. 1. 그냥 빈 리스트이거나 2. 다른 리스트와 원소 하나를 받아서 새 리스트를 만든거나. 백마디 말보다 한 줄 코드가 이해하기 쉽다고, 파이썬 코드로 아이디어를 표현하면 이렇게 된다.
```python
def empty_p():
  return []

# constructor_python의 약자이다
def cons_p(x, ls):
  return [x] + ls
```
이 함수들을 써서 `[3,1,2]`를 나타내면 이렇게 된다.
```python
cons_p(3, cons_p(1, cons_p(2, emtpy_p))) #=> [3,1,2]
```

이제 필요한 정보는 다 있다. 아래의 테스트를 통과하도록 람다식 리스트를 정의해보자.
```python
def empty():
  pass

def cons(x, ls):
  pass

sample_list1 = cons(1, cons(2, cons(3, empty)))
sample_list1(lambda x,y: x+y, 0) #=> 6

sample_list2 = cons("aaa", cons("bbb", empty))
sample_list2(lambda s1,s2: s2 + s1, "ccc") #=> "bbbaaaccc"

sample_list3 = cons(one, cons(two, cons(three, empty)))
c2n(sample_list3(add, zero)) #=> 6
c2n(sample_list3(mult, six)) #=> 36
```

리스트의 사용을 fold로 정의한데는 그만한 이유가 있다. 우리가 리스트에 수행하는 거의 모든 작업들은 fold를 이용해 구현될 수 있기 때문이다. 그런 작업들을 나열하자면 수없이 많지만 여기서는 map, append, reverse, zip, filter만 구현해보자.

아래의 도우미 함수들이 코드를 테스트하는데 유용할 것이다.
```python
def push_back(ls, x):
  ls.append(x)
  return ls

# 람다식 리스트를 파이썬 리스트로 바꾼다.
def c2l(ls):
  return ls(push_back, [])

# 처치식 정수들로만 이루어진 리스트를 파이썬 데이터로 변환해서 화면에 출력해준다.
def printNatList(ls):
  print(list(map(c2n, c2l(ls))))

print(c2l(cons(1, cons(2, empty)))) # [1, 2]
ls1 = cons(one, cons(three, cons(two, empty)))
printNatList(ls1) # [1,3,2]
```

#### length

리스트의 길이를 리턴한다. 아주 대표적인 polymorphic 리스트 오퍼레이션 중 하나인데, 리스트안에 무엇이 담겨있던지 (정수든, 함수든..) 상관없이 작동하기 때문이다. 데이터를 신경쓰지 않는다는 점에 착안하면 간단히 구현할 수 있다. 아 물론 처치식 자연수를 리턴해야 한다.

```python
def length(ls):
  pass

c2n(length(ls1)) #=> 2
c2n(length(sample_list3)) #=> 3
```

#### map

MapReduce의 map이다. 함수와 리스트를 받아 각 리스트의 원소에 적용한 새 리스트를 리턴해준다. 백문이 불여일코드, 파이썬에 이미 같은 이름과 기능의 함수가 있다.
```python
map(lambda n: n//2 if n%2==0 else 3*n+1, [4, 3, 1, 2])
  #=> [2, 10, 4, 1]
```

구현하라.
```python
# 파이썬의 빌트인 map과 충돌을 피하기 위해 언더스코어를 붙였다.
def map_(f, ls):
  pass

ls2 = cons(four, cons(three, cons(one, cons(two, empty))))
ls3 = map(lambda n: add(one,mult(three,n)), ls2)
printNatList(ls3) # [13, 10, 4, 7]
```

#### append

두 리스트를 이어붙이는 함수이다. 파이썬에서 리스트에 대해 오버로딩된 + 연산자와 같다. 구현하라.

```python
def append(xs, ys):
  pass

ls4 = cons(two, cons(three, cons(one, empty)))
ls5 = append(ls1, ls4)
printNatList(ls5) # [1, 3, 2, 2, 3, 1]
```

#### reverse

리스트를 뒤집어주는 함수다. 파이썬에는 리스트의 메소드로 같은 함수가 있다. 리스트의 길이를 알아낸 다음 뒤에서부터 인덱싱하면 손쉽게 구현할 수 있지만 우리는 아직 인덱싱을 할 수 없다. 사실 램덤액세스가 가능한 c 어레이와 다르게 이런 리스트는 인덱싱이 O(n)이기 때문에 그렇게 좋은 정의는 아니다. 여기서는 어큐뮬레이터로 리스트를 사용하면 깔끔하게 정의할 수 있다.

```python
def reverse(ls):
  pass

printNatList(reverse(ls4)) # [1, 3, 2]
```

#### zip

두 리스트를 결합해 튜플의 리스트를 리턴한다. 파이썬에 같은 함수가 있다. 지면 절약을 위해 파이썬 함수를 보고 동작을 유추하는것으로 하자. reverse와 비슷한 기법으로 해결할 수 있다.
```python
def zip_(xs, ys):
  pass

c2l(map_(
  lambda tup: c2n(fst(tup)), c2n(snd(tup))
, zip_(ls4, ls5))) #=> [(2,1), (3,3), (1,2)]
```

#### filter

filter는 리스트에서 조건에 맞지 않는 원소들을 골라내는 함수이다. 조건은 인자로 주는 함수로 넘겨준다. 마찬가지로 파이썬에도 같은 함수가 있으니 자세한 설명은 파이썬 레퍼런스를 보자.

```python
def filter_(f, ls):
  pass
```

아쉽게도 filter는 아직 테스트 해볼 수 없다. 우리가 불리언을 정의하기는 했지만 불리언을 리턴할 수 있는 비교함수는 하나도 안 만들었기 때문이다. 없는대로 예제를 만들면 이정도가 최선이다.
```python
ls7 = cons(con(true, one), cons(con(false, two), cons(con(true, three), empty)))
print(NatList(map(snd, filter(fst, ls7))) # [1, 3]
```
### 다시 리스트

리스트의 사용을 튜플과 마찬가지로 '선택'으로 생각한다면 튜플만을 이용해 정의할 수도 있다. 보통 함수형 언어에서는 이렇게 정의한다.
TODO

### 재귀

minus
head
tail

# Comments
[1]: 대학신문 - 완벽을 추구한 한 수학자의 이야기 (http://www.snunews.com/news/articleView.html?idxno=11883)

[2]: 논리학에서 ambiguity는 중의적 단어, vagueness는 판정이 확실치 않은 경우를 의미한다. [3]

[3]: Stanford Encyclopedia of Philosophy

[4]: 괴델의 증명 - 어니스트 네이글, 제임스 뉴먼, 더글러스 호프스태터

[5]: Lambda Days 2016 speach - Philip Wadler (https://www.youtube.com/watch?v=aeRVdYN6fE8)

[6]: 의미(semantic)가 기호의 조작규칙에 있다는 것은 문장으로는 생소하지만 형식체계의 기본적인 아이디어 중 하나이다. "¬ (T ∧ F) ∨ X"는 단지 기호의 나열일 뿐이다. 여기에 '∧'와 '∨'의 계산규칙, 간략화 규칙등이 적용되면 'T'로 바뀔 수 있다. 그리고 그 규칙들이 부울대수에 '참과 거짓의 연산'이라는 의미를 가져온다. 만약 '∨'의 계산규칙이 "T ∨ T => 3" 따위였다면 우리는 그런 시스템을 '참과 거짓의 연산'이라는 의미로 생각하지 않을 것이다.

[7]: 기호의 조작규칙에 의해 부여될 수 있는 의미(semantic)는 한가지가 아닐 수도 있다. 예를 들어 Classical Logic의 조금 제한적인 버전인 Intuitive Logic은 보통 '증명가능성과 증명 불가능성의 연역'이라는 의미로 해석되지만 여전히 '참과 거짓의 연역'으로 해석할 여지가 있다. 그러나, 의미가 어떻게 되는지는 중요하지 않다. 수학에서 의미를 모두 걷어내고 문법과 조합규칙의 기계적 적용으로 환원시키는 것이 형식체계의 핵심이기 때문이다. 의미는 체계를 다루는 사람의 직관적 이해와 편의를 위해서만 부여된다.

[8]: 웬만하면 한국어로 변역하려고 했는데 번역어를 못찾았다. First-class function을 지원한다는 것은 함수를 변수에 저장하고 다른 함수에 인수로 전달하거나 함수의 반환 값으로 리턴하는것이 가능함을 뜻한다. 특히 함수를 리턴하는 기능은 curry를 구현하는데 주로 사용한다.

[9]: 사실 정의할 수는 있다. 결과값이 음수가 된다면 그냥 0을 반환하는 것이다. 이 구현은 Recursion 챕터에서 다룬다.

[10]: 루비같은 언어에서는 자연수를 반복이라는 의미로 사용하는것을 권장한다. 3.times { puts "pip" } 이라고 쓰면 블럭을 세 번 실행하게 된다. 아쉽게도 반복적용(iterating)은 아니다.

[11]: 계속 '처치식'이라는 표현을 쓰다가 람다식으로 바꾸었는데, 자연수와 불리언을 제외하고는 처치가 직접 정의했는지 (본인은) 모르기 때문이다. 표현만 다르고 같은 의미이다. 헷갈리지 말자.

[12]: 다시 말하지만 의미는 실제로 어떻게 생겼는지와 관계없이 조작규칙에 의해 부여되는 것이다. 튜플의 조작규칙에 의해 (3, 4)와 (5, 6)이 동일하게 취급된다면 적힌 기호(숫자)가 틀린것은 상관이 없다.
