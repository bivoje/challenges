
https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus

#### 예상 독자
* 파이썬을 아는 사람. 적어도 `lambda`랑 `pass` 키워드가 뭔지 아는사람.
* Calculus정도 수학강의를 수강한 사람

Lambda C
============

본 첼린지는 람다대수의 기본적인 개념과 구현을 프로그래밍 언어를 이용해 직접 실습해 본다. 람다대수가 무엇인지, 왜 중요한지 이해하기 위해서는 우선 약간의 역사공부가 필요하다.

## 역사공부

20세기 초, 다비트 힐베르트는 '힐베르트 프로그램'이라는 구상을 한다. 수학을 형식화해 그 형식체계가 무모순임을 유한적 방법으로 증명할 수 있다"는 것이다. 이는 "산술의 무모순성 증명"이라는 이름으로 힐베르트의 23가지 문제에도 2번째로 포함되어있다. [1]

그는 저서 "기하학의 기초"에서 산술적 무모순성을 가정했을때 기하학이 무모순임을 증명할 수 있었다. 그리고 이제 남은 것은 현 수학의 형식체계의 무모순성 증명뿐일 터였다.
그러나 20대 청년 괴델이 불완전성 정리을 들고 나와 "현 수학(을 나타내는 형식체계)의 무모순성은 메타수학 없이는 증명할 수 없다"는 것을 증명하게 된다.

여기서 '형식체계'란 모종의 규칙들을 이용해 공리로부터 정리를 연역하는 체계를 의미한다. 쉽게 말해 우리가 평소에 부르는 수학과 수학적 증명을 나타내는 말이다. 다만 우리는 형식체계를 연구한 많은 수학자들 덕분에 연역적 증명체계와 그 공리들이 당연한 것이라고 (as granted) 믿고 넘어갈 수 있는 것이다.

형식체계는 자연어로 표현될 수도 있지만 기호가 빈번히 사용된다. 자연언어는 종종 모호(ambiguity)하고 애매(vague)하기 때문이다.[2] 사실 영어나 한국어로 표현해도 알파벳이나 한글이라는 기호로 표현하는 것이지만, 애매성과 모호성을 제한 새로운 표현체계를 이용한다는데 그 의의가 있다. 또한, 그러한 기호체계를 사용해서 서술한다면 형식체계를 증명하고 계산하는일이 쉬워지기도 한다.

형식체계를 기호만으로 표현하는 방법은 한가지가 아니다. 그 중 대표적인것이 '괴델 수'이다. 쿠르트 괴델이 불완전성 정리를 증명하는 과정에서 사용한 시스템으로, 형식체계에서 기호로 표현되는 명제를 자연수로 번역하는 방법이다. 괴델은 임의의 형식체계와 괴델 수의 isomorphism이 존재한다는 것을 보이고, 자연수에 대한 조작을 함으로써 목적을 달성할 수 있었다. [4]

힌편, 형식체계에서의 증명은 어떤 의미에선 알고리즘으로 볼 수도 있다. 완전히 기호만을 사용해 서술된 명제와 증명은 결국 "일련의 기호들(가정)을 이렇게, 그리고 또 저렇게 조작하면 결과(결론)가 나온다"는 서술이기 때문이다. 때문에 형식체계에 대한 연구는 알고리즘의 정의로 넘어오게 된다.

무엇이 알고리즘인지 정의하는 첫 번째 시도는 알론조 처치의 학위논문에서 나왔다. 그는 '람다대수'라는 체계를 고안해 우리가 아는 모든 알고리즘은 이것으로 증명할 수 있다고 가정했다. 하지만 그가 정의한 대수체계는 너무나 단순해서 컴퓨터 과학의 수많은 복잡다단한 알고리즘들을 다 표현할 수 없을 것 같았다. 마침 지나가던 괴델이 처치의 정의를 보고 너무 제한적이라고 (람다대수로 표현할 수 없는 알고리즘이 있을 것이라고) 생각해 직접 새로운 정의를 만들기로 한다. [5]

괴델은 그 후 Recursive functions라는 정의를 만들어냈다. 처음엔 자신의 정의가 람다대수를 포함하는 더 일반적인 정의일 것이라 생각했으나 후에 람다대수와 동치인 시스템이라는것이 밝혀졌다. 처치의 시스템을 비판했던 괴델은 자신의 정의에도 뭔가 실수가 있어 보편적이지 않은 시스템이 되었다고 생각했을 것이다. [5]

알고리즘의 세 번째 정의는 우리가 모두 잘 아는 앨런 튜링에서 나온다. 튜링은 '계산 가능한 문제'의 정의를 '튜링머신이 풀 수 있는 문제'라고 정의했다. 튜링머신은 테이프, 테이프 위의 장치, 테이프 R/W 규칙으로 이루어진, 다분히 기계적으로 보이는 구상이다. 튜링이 앞선 두 정의를 알았는지는 모르지만, 순수 수학적으로 정의된 앞선 두 체계와는 동떨어져 보인다. 그러나 나중에 밝혀지길 튜링머신과 괴델, 처치의 정의는 모두 동치라는것이 증명되었다. [5]

이쯤 되면 수학자들은 믿기 싫어도 믿을 수밖에 없게 된다. 독자적으로 개발된 3개의 시스템이 사실은 모두 동치였다는 것은, 처치와 괴델, 튜링이 각자의 시스템을 '만들어 낸 것'이 아니라 '발견해낸 것'임을 강하게 시사하는것처럼 보인다. 그게 진짜인지는 모라도 어쨌든 수학자들 그들의 시스템으로 계산가능성(computability)이란 개념을 정의하기로 합의를 보게 된다. 그 뒤에 DFA, NFA, Combinatory logic 등등이 동치임이 밝혀졌다.

----------
[1]: 대학신문 - 완벽을 추구한 한 수학자의 이야기 (http://www.snunews.com/news/articleView.html?idxno=11883)
[2]: 논리학에서 ambiguity는 중의적 단어, vagueness는 판정이 확실치 않은 경우를 의미한다. [3]
[3]: Stanford Encyclopedia of Philosophy
[4]: 괴델의 증명 - 어니스트 네이글, 제임스 뉴먼, 더글러스 호프스태터
[5]: Lambda Days 2016 speach - Philip Wadler (https://www.youtube.com/watch?v=aeRVdYN6fE8)


## 람다대수

본 항목은 람다대수의 기본적인 설명을 담고있다. 본인이 람다대수의 전문가가 아니기 때문에 간단히 위키피디아 페이지를 훑어보는게 본 항목을 읽는 것보다 도움이 될 지도 모른다. 너무 많이 읽으면 실습부분을 스포당하니 조심해야 한다. 도입부분만 읽어보자.

### 문법 (syntax)

람다대수는 아주 간단하다. 문법 (표현식)을 BNF로 나타내면 이렇게 된다.
```
L, M, N ::= x | (λx. N) | (L M)
```
이것을 말로 풀어서 써 보자.
```
L, M, N을 임의의 람다식이라 할 때, 람다식은 다음 세 가지 형태 중 하나이다.
1. x:
  변수(x)
2. (λx. N):
  추상화(x, N)
3. (L M):
  적용(L, M)
```
각 형태 밑에는 이해를 돕기 위해 AST(Abstract Syntax Tree)를 붙였다. 앞으로 람다식의 구조를 설명하는데 한정적으로 사용할 것이다.

여기에는 문법적 구조(syntactic structure)만 설명되어 있을 뿐 각 1번 2번 3번 형태가 무슨 의미인지에 대한 정보는 없다. 문법은 그저 주어진 식이 유효한 람다식인지 확인하기 위해서만 존재하기 때문이다. 가령 여러분이 어느날 척 봐도 복잡해보이는 이런 람다식을 마주쳤다고 하자.
```
# 험악해 보이는 람다식
((λh. (λx. (h (x x))) (λx. (h (x x)))) g)
```
여러분은 위의 문법 설명만을 보고도 이 식이 올바른 식인지 판별할 수 있다. 식이 무슨 구조/연산을 서술하는지 알 수는 없어도 말이다. 람다식 그 자체로는 아무런 의미가 없다. 그저 문법에 맞게 기호들이 조함되어 있을 뿐이다.

일단 문법에 익숙해지기 위해 예시를 들어보겠다. 몇 가지 람다식과 그 AST 구조를 표현하면 다음과 같다.

1. `(λz. z)`:
  추상화(z, 변수(z))
2. `(w x)`:
  적용 (변수(w), 변수(x))
3. `(λz. (x z))`:
  추상화(z, 적용(변수(x), 변수(z)))
  _이 밑으로는 변수()를 생략한다. 너무 길고 복잡해지니까._
4. `(λx. ((λy. x) y))`:
  추상화(x, 적용(추상화(y, x), y)))
5. `((w x) y) z`:
  적용(적용(적용(w, x), y), z)
6. `(λc. (z (λz. x (y z))))`:
  추상화(c, 적용(z, 추상화(z, 적용(x, 적용(y, z))))
7. `((λh. (λx. (h (x x))) (λx. (h (x x)))) g)`:
  적용(추상화(h, 적용(추상화(x, 적용(h, 적용(x, x))), 추상화(x, 적용(h, 적용(x, x))))), g)

'변수'에는 보통 알파벳 소문자가 사용된다. 한번에 변수가 26개 이상 나오는 복잡한 람다식은 여기서 볼 일이 없으니 알파벳 소문자면 충분하다. 게다가 나머지 문법규칙은 새로운 기호를 도입하지 않는다. 그러니 앞으로 나올 람다식에서 람다, 괄호, 알파벳 소문자가 아닌 문자를 본다면 다른 람다식을 의미하는 메타변수로 해석하면 된다.

원래 람다식은 추상화와 적용을 사용할 때 괄호를 쓰는것이 기본이다. 하지만 그렇게 쓰면 식이 너무 더러워지므로 모호하지 않은 선에서 괄호를 생략해서 쓸 수도 있다. 대략의 규칙은 이러하다.
1. 추상화는 가능한 한 길게, 문장의 끝이나 닫는괄호까지 포함한다. `λx. y z`는 `(λx. y) z`가 아니라 `λx. (y z)`으로 해석한다.
2. 적용은 맨 왼쪽부터 한다. `w x y z`는 `((w x) y) z`으로 해석한다.
3. 겹친 괄호는 하나로 만든다. `((X))` => `(X)`
4. 맨 바깥 괄호는 생략한다. `(λz. z)` => `λz. z`
이 간단화-규칙들은 람다식의 AST를 바꾸지 않는다. AST를 바꾼다면 그것은 간단히 하는게 아니라 식을 연산/변형하는것이기 때문이다. 그런 규칙들은 다음 챕터인 `의미론`에서 다룬다.

간단화-규칙들에 따라 앞선 예시 리스트의 람다식들에서 괄호를 없애면 다음과 같아진다.
1. `λz. z`
2. `w x`
3. `λz. x z`
4. `λx. (λy. x) y`
5. `w x y z`
6. `λc. z λz. x (y z)`
7. `(λh. (λx. h (x x)) (λx. h (x x))) g`
이 상태에서 괄호를 하나라도 빼면 람다식의 AST가 달라진다. 아직 람다식의 문법이 잘 이해가 가지 않는다면, 임의의 위의 식 중에서 임의의 괄호를 뺐을때 AST가 어떻게 바뀌는지 확인해 보는것이 좋은 연습이 될 것이다.

### 의미론 (semantic)

이제 람다식에 의미를 부여할 차례이다. 수학, 정확히 말하면 형식체계에서는 기호로 이루어진 표현식을 변형하는 '조작규칙'을 정의함으로써 식에 의미(semantic)를 부여한다. [1] [2] 마찬기지로 여기에서도, 람다식을 어떻게 조작할 수 있는지 정의하며 의미를 찾아볼 것이다. 람다대수의 조작규칙들은 람다식의 문법에 수학(혹은 프로그래밍)에서의 사용하는 함수정의/함수적용과 유사한 의미를 가져온다. 비록 그런 '의미'가 본절적인 것은 아니지만 편의를 위해 앞으로의 설명에서는 추상화를 함수, 적용을 함수적용, 변수를 함수의 지역변수에 비유하며 설명하겠다.

람다대수에는 기본적으로 두 가지 규칙이 있는데 둘 다 추상화(함수)와 관련이 있다.[3]

* α-변환 (λx.M[x]) → (λy.M[y])

`추상화(x, M_x)`에서 `추상화(y, M_y)`로 변환하는 규칙이다. 이때 `M_y`는 `M_x`에서 모든[4] `변수(x)`를 `변수(y)`바꾼 람다식이다. 함수로 치면 파라메터 변수 이름 바꾸기이다. 기능적으로는 함수의 몇 번째 인수에 무엇이 들어오느냐가 중요할 뿐 변수 이름이 어떤가는 함수 실행에 영향을 미치지 않는다. 따라서 α-변환은 식이 서술하는 내용을 바꾸지 않음을 어렵지 않게 생각할 수 있다.

```
       (λx. x ((λx. x y) (λz. z)))
  =α=> (λa. a ((λx. x y) (λz. z)))
  =α=> (λa. a ((λb. b y) (λz. z)))
  =α=> (λa. a ((λb. b y) (λc. c)))
```

* β-축약 ((λx.M) E) → (M[x:=E])

`적용(추상화(x, M), E)`의 꼴로, AST에서 `적용`과 `추상화`가 순서대로 겹쳐있으면 소거할 수 있는 규칙이다. 소거 후에는 안쪽 `추상화`의 몸체(`M`)가 밖으로 나오는데, `M`안의 모든[4] `x`는 `E`로 바뀐다. 말하자면 함수를 인수에 적용하는 것이다. SICP [5]의 설명을 빌리자면, 맞바꿈 계산법을 사용하는 것이다. [6]

```
# 간단한 예시
   (λy. x y) z
  =β=>  x z

# 복잡한 예시
       (λx. x ((λx. x y) (λz. z))) (λk. k l)
  =β=> (λx. x     ((λz. z) y))     (λk. k l)
  =β=> (λx. x           y)         (λk. k l)
  =β=>      (λk. k l)   y
  =β=>           y l
```

이렇게 두 가지 규칙을 보면 앞서 이야기했던 함수의 비유가 와닿을 것이다. 하지만 사실 람다대수의 semantic은 아직 명확하게 밝혀져 있지 않다. 처치가 처음 설계할 때는 함수공간에서 함수공간으로 가는 동형사상이 될 것으로 예상했으나 사실이 아닌것으로 밝혀졌다. [7] 하지만 그럼에도 그러한 비유가 본 첼린지를 진행하는데 있어 람다식을 설계하고 조작하는데 도움을 줄 것이다. TODO..?

----------
[1]: 의미(semantic)가 기호의 조작규칙에 있다는 것은 문장으로는 생소하지만 형식체계의 기본적인 아이디어 중 하나이다. 조작규칙이 없다면 형식논리의 "¬ (T ∧ F) ∨ X"라는 표현은 단지 기호의 나열일 뿐이다. 여기에 '∧'와 '∨'의 계산규칙, 간략화 규칙 등의 형식논리에서 정의한 조작규칙을 적용해서 'T'로 바꿀 수 있다. 이런 규칙들이 비로소 부울대수에 '참과 거짓의 연산'이라는 의미를 가져온다. 만약 '∨'의 계산규칙이 "T ∨ T => 3" 따위였다면 우리는 그런 시스템을 '참과 거짓의 연산'이라는 의미로 생각하지 않을 것이다.
[2]: 기호의 조작규칙에 의해 부여될 수 있는 의미(semantic)는 한가지가 아닐 수도 있다. 예를 들어 Classical Logic의 조금 제한적인 버전인 Intuitive Logic은 보통 '증명가능성과 증명 불가능성의 연역'이라는 의미로 해석되지만 여전히 '참과 거짓의 연역'으로 해석할 여지가 있다. 그러나, 의미가 어떻게 되는지는 중요하지 않다. 수학에서 의미를 모두 걷어내고 문법과 조합규칙의 기계적 적용으로 환원시키는 것이 형식체계의 핵심이기 때문이다. 의미는 체계를 다루는 사람의 직관적 이해와 편의를 위해서만 부여된다.
[3]: 사실 유명한 규칙이 하나 더 있긴 한데, functional_extensionality라는 어려운 이름의 수학개념을 가져와야 하거니와 본 첼린지에는 그닥 도움이 되지 않기 때문에 설명하지 않기로 한다. 궁금한 사람은 η-conversion이라고 구글에 검색해보자.
[4]: 두 규칙에서 '모두'라고 썼지만 둘 다 다른 의미로 틀린 표현이다. 정확히 표현하자면 너무 복잡해지기때문에 생략했다. 대신 함수의 비유로 생각하며 규칙을 추론하도록 하자. 대부분의 경우 그런 추론이 들어맞는다.
[5]: Structure and Interpretation of Computer Program. Lisp 언어를 사용해 프로그래밍이란 무엇인지 설명하는 입문서. MIT에서 출판된지 25년이 지난 최근까지도 사용했던 희대의 명저다. 사족으로 본 첼린지의 자연수 챕터에 나오는 구현들이 SICP에서 연습문제로 나오기도 한다.
[6]: 맞바꿈 계산법을 사용하면 한 글자로 쓰던 변수를 여러 글자(식)으로 쓰게 되니 전체 길이가 계속 늘어날 것 같지만 사실은 그렇지 않다. 보통은 AST가 줄어들기 때문이다. 물론 그렇지 않은 경우도 있다. 그런 람다식은  Recursion 챕터에서 다룬다.
[7]: TODO! citation needed!


## 함수형 프로그래밍

본 첼린지는 함수형 프로그래밍에서 사용하는 용어와 기법들을 적극 사용한다. 사실 함수형 프로그래밍의 개념이 람다대수에서 나왔기 때문에 그리 새삼스러운 일도 아니다. 현존하는 대부분의 함수형 프로그래밍 언어들은 람다대수에 기반을 하고있고, 그를 벤치마킹한 파이썬도 마찬가지로 많은 교집합을 가지고 있다. 가령 예를 들면, 파이썬에서 이름없는 간단한 local 함수를 정의하고 싶을때 사용하는 lambda 키워드가 바로 람다 대수의에서 '추상화'에 사용하는 기호 (λ)를 따온 것이다. 그래서 여기서는 함수형 언어에 자주 사용되는 개념을 미리 공부해 두기로 한다.

### Currying

함수의 정의에 해당하는 람다 대수의 추상화 문법은 변수를 하나밖에 받지 않는다.
```
(λx. N)
```
즉, 일변수 함수밖에 표현할 수 없게 된다. 그렇다면 우리는 람다대수에서 간단한 덧셈함수도 정의할 수 없는 것일까?
```
add(x, y) = x + y
```
이를 해결하기 위해 연구된 개념이 currying이다. 논리학자 Haskell Curry의 이름을 따서 그렇게 부른다.

currying은 다변수 함수를 **같은 기능의** 일변수 함수로 번역하는 기법이다. 가령 다음과 같이 추상화가 두 번 겹쳐진 람다식이 있다고 하자.
```
λx. λy. M
```

이 식을 변수 a와 b에 대해 적용하면
```
(λx. λy. M) a b
  = ((λx. (λy. M)) a) b
  =β=> (λy. M[x:=a]) b
  =β=> M[x:=a][y:=b]
  = M[x:=a, y:=b]
```
이렇게 M에 두 변수를 동시에 적용시킨것과 같은 효과가 난다. 여기서 `λx. λy. M`라는 식은 "변수 하나(x)를 인자로 받아 '변수 하나(y)를 인자로 받는 함수'를 반환하는 함수"로 해석할 수 있다.

이를 간단히 다변수 함수처럼 쓰기도 한다.
```
λxy. M
```

파이썬으로 다시 설명해 보자. 예컨대, 다음과 같은 간단한 함수가 있다고 하자.
```python
def div(a, b):
  return a / b
```
`div` 함수는 2변수 함수이다. 변수 두 개를 한꺼번에 받아서 적용한 결과를 돌려주기 때문이다. 반면 같은 기능을 하는 함수를 1변수 함수로 정의할 수도 있다.

```python
def div_(a):
  return lambda b: a / b
```
`div_` 함수는 인자를 한꺼번에 받지 않고 따로따로 받는다. 정확히 말하면 `div(x)`는 '인자를 하나 받아 `x/y`라는 값을 돌려주는 일변수 함수'를 리턴한다. 두 함수의 기능과 사용을 보이면 이렇게 된다.
```python
div(60, 4) #=> 15
div_(60)(4) #=> 15
```

`div_`함수를 이해하기 위해 함수를 하나 더 만들어보자.
```python
def div_60(b):
  return 60 / b
```
`div_60` 함수는 보다시피 인자를 하나 받아 60으로 나눈 몫을 리턴한다. 이 함수는 기능적으로 볼 때 `div_(60)`이 리턴한 함수와 완벽히 같다.
```python
fun = div_(60)
fun(12) #=> 5
div_60(12) #=> 5
div_(60)(12) #=> 5
```

몇몇 함수형 언어들은 currying을 기본적으로 지원하기도 한다. 다변수 함수를 정의하면 자동으로 currying 해 두는 것이다. 예컨대 haskell에서는
```haskell
func a b c d = a - b + c - d
vunc = func 1 2
print(vunc 3 4) --> -2
```
이렇게 작동한다. 하지만 아쉽게도 파이썬은 꼴에 함수형 패러다임을 도입하면서도 currying은 지원하지 않는다. 다변수 함수나 그것을 currying한 일변수 함수나, 기능적으로는 같은 대상이지만 변수를 취급하는 방법이 달라 섞어서 사용할 수 없다. 특히 람다식을 번역하는 과정에서 currying된 일변수 함수를 빈번히 사용하게 될 텐데 그때마다 함수를 다시 정의해야 하면 귀찮을 수밖에 없다. 그래서 다음의 두 도우미 함수를 제공한다.

```python
# 2변수 함수를 1변수 함수로 바꿔준다.
def curry2(f):
  return lambda x: lambda y: f(x, y)

# currying형 1변수 함수를 2변수 함수로 바꿔준다.
def uncurry2(f):
  return lambda x, y: f(x)(y)
```

예를 들어, `curry2(div)`는 `div_`와 같고, `uncurry2(div_)`는 `div`와 같다. 만약 필요한 함수(`my_add`)를 2변수 형태로 정의했는데 본 첼린지의 정의는 1변수를 필요로 한다면
```python
add = curry2(my_add)
```
이런 식으로 사용할 수 있다. 위의 컨버터들은 2변수 함수만 바꿔준다는 의미로 이름에 2를 붙였다. 3변수, 4변수 currying 컨버터는 필요에 따라 직접 만들어 사용하도록 하자.


## 실습

람다대수는 굉장히 간단한 시스템이지만 모든 계산가능한 문제를 서술할 수 있다. 피보나치 수열, 유클리드의 gcd 알고리즘, backpack문제 등 무엇이든 가능하다. 실제로 컴퓨터를 이용해 증명된 첫 수학문제라는 타이틀로 유명한 4색문제는, 람다대수를 바탕으로 설계된 시스템을 이용해 증명되었다.

가진게 함수, 변수, 적용 밖에 없는데 어떻게 그런 복잡한 문제를 서술/해결할 수 있을까. 그 비밀은 람다대수의 창시자인 알론조 처치의 천재성에 있다. 불리언이나 자연수같은 기본적인 것들은 맨 처음 처치의 학위논문에서 람다대수의 정의와 함께 개발되었다.[1] 앞으로의 실습에서는 그의 정의를 따라 몇가지 간단한 개념들을 람다식으로 정의해 볼 것이다. 그리고 람다식으로 써놓기만하면 맞게 했는지 알 수가 없으니 practical한 프로그래밍 언어로 실제 구현을 해 보도록하자. 본인의 람다식을 번역한 코드가 예상한 답을 낸다면 직접 설계한 람다식이 적어도 넌센스가 아니란 건 알 수 있으니까.

실습에 사용할 언어는 함수를 자유자재로 사용할 수 있어야 한다. 꼭 함수형 언어가 아니더라도 최근의 웬만한 프로그래밍 언어들은 First-class function[2]을 지원하기 때문에 적당한 언어를 고를 수 있다. 여기에서는 파이선3을 이용한다. 파이썬의 함수 정의를 람다 대수의 추상화, 함수 호출을 β-축약으로 사용할 것이다.

다만, 대부분의 언어들이 람다식의 번역에 필요한 최소문법보다 더 많은 syntactic sugar를 내장하고 있기 때문에 주의할 필요가 있다. 함수 정의와 사용을 제외한 거의 대부분의 기능을 제한해서 써야 한다.  `if` 제어구조나 정수, 튜플, 리스트 등은 설명이나 테스트를 위한 코드에서 제한적으로만 사용된다. `while`, `for`와 같은 루프들은 재귀를 통해 구현하면 전혀 사용할 필요가 없다. 또한, 그 외에 딕셔너리, 클래스, 모듈, 예외처리, 내장/시스템 함수 등은 말할 것도 없이 쓰임이 없다.

실습은 "problem.py" 파일에서 몸체가 비어있는 함수 (`pass`)들을 구현하며 진행된다. 구현과 실습에 필요한 함수들은 이미 다 정의되어 있다. "test.py"는 "problem.py"를 import하여 정의된 함수들이 잘 작동하는지 테스트한다. 모든 테스트를 통과해야지만 제대로 첼린지를 수행한 것이다. TODO!

----------
[1]: TODO! citation needed
[2]: 웬만하면 한국어로 변역하려고 했는데 번역어를 못찾았다. First-class function을 지원한다는 것은 함수를 변수에 저장하고 다른 함수에 인수로 전달하거나 함수의 반환 값으로 리턴하는것이 가능함을 뜻한다. 특히 함수를 리턴하는 기능은 curry를 구현하는데 주로 사용한다.


### 자연수

알론조 처치는 람다대수에서 자연수 n을 '함수 f를 인자로 받아 f를 n번 반복 적용하는 함수 fn을 리턴하는' 함수로 표현할 수 있음을 발견했다.[1] 다시말해, 자연수를 처치식으로 나타내는 함수는, 함수를 인수로 받아서 기능을 조작/덧붙인 후 새로운 함수를 찍어내는, 함수 공장 (function factory)내지는 함수 조작기라 생각할 수 있다. 말로만 하면 딱딱하니 파이썬 코드로 예시를 만들어보자.

문자열의 맨 뒤에 " pip"이라는 문자열을 덧붙여주는 `append_pip`이라는 함수가 있다고 하자. `one`, `three`라는 함수가 처치식으로 정의된 자연수라고 하면 `append_pip`에 대해 이렇게 작동할 것이다.
```python
def append_pip(str):
  return str + " pip"

one_pip = one(append_pip)
three_pip = three(append_pip)
one_pip("counting..")   #=> "counting.. pip"
three_pip("counting..") #=> "counting.. pip pip pip"
```

`one`과 `three`를 람다식으로 적는것은 어렵지 않다. 둘 다 아주 기본적인 함수 적용일 뿐이니까.
```
# one
λf. (λx. (f x))

# two
λf. (λx. (f (f x)))

# three
λf. (λx. (f (f (f x))))
```
_위의 코드는 이해를 돕기 위해 병적으로 괄호를 추가하였다. 앞으로는 불필요한 괄호는 되도록 생략한 형태로 사용할 것이다._

같은 식을 파이썬으로 번역하면 이렇게 된다.
```python
def one(f, x):
  return f(x)

def two(f, x):
  return f(f(x))

def three(f, x):
  return f(f(f(x)))
```
_위의 코드는 uncurrying된 형태로 쓰였음을 감안하라._

이런 식으로 정의하면 이론적으론 모든 자연수에 대해 처치식 자연수를 정의할 수 있다. 하지만 그 많은 자연수를 모두 직접 정의하기에는 힘에 부치기와, 자연수 사이의 순서 개념이 없어서 써먹기도 영 신통치 않다. 그래서 현대 수학에서는 페아노 공리계[2]의 정의를 따라 0과 successor함수를 통해 정의한다. 처치도 같은 방식을 따라 처치식 자연수를 정의했다.

```
# zero
Z := λf. λx. x

# successor
s := λn. λf. λx. n f (f x)
```

이를 이용해서 처치식 자연수 3을 정의해보면 `S (S (S Z))` 이렇게 쓸 수 있다. 여기에 β축약을 사용하면 처음 만들었던 정의를 얻을 수 있다.
```
     S (S ( S                                              Z            ))
===> S (S ((λn1. λf1. λx1.  n1                f1 (f1 x1)) (λf0. λx0. x0)))
=β=> S (S (      λf1. λx1. (λf0. λx0. x0    ) f1 (f1 x1)                ))
=β=> S (S (      λf1. λx1. (     λx0. x0    )    (f1 x1)                ))
=β=> S (S (      λf1. λx1.           (f1 x1)                            ))

===> S ( S                                                 (λf1. λx1. f1 x1))
===> S ((λn2. λf2. λx2.  n2                    f2 (f2 x2)) (λf1. λx1. f1 x1))
=β=> S (      λf2. λx2. (λf1. λx1. f1  x1    ) f2 (f2 x2)                   )
=β=> S (      λf2. λx2. (     λx1. f2  x1    )    (f2 x2)                   )
=β=> S (      λf2. λx2.            f2 (f2 x2)                               )

===>  S                                                      (λf2. λx2. f2 (f2 x2))
===> (λn3. λf3. λx3. n3                          f3 (f3 x3)) (λf2. λx2. f2 (f2 x2))
=β=>       λf3. λx3. (λf2. λx2. f2 (f2  x2    )) f3 (f3 x3)
=β=>       λf3. λx3. (     λx2. f3 (f3  x2    ))    (f3 x3)
=β=>       λf3. λx3. (          f3 (f3 (f3 x3)))

===> λf3. λx3. (f3 (f3 (f3 x3)))
=α=> λf.  λx.  (f  (f  (f  x )))
```
각 단계는 간단하게 앞에서 설명했던 정의들을 기계적으로 적용할 뿐이지만, 매번 새로운 람다식을 볼 때마다 이렇게 확인하려면 종이가 남아나지 않을 것이다. 그래서 본 첼린지에서는 람다식을 파이썬으로 번역한 후 직접 실행해 보는 방법으로 확인을 한다. 그렇게 하면 본인이 적은 람다식이 제대론 된 것인지 확인해보는 지루한 과정이 0.1초만에 끝난다.

파이썬으로 번역한 페아노-처치식 자연수는 아래와 같다.
```python
def zero(f, x):
  return x

def s(n):
  return lambda f, x : f(n(f,x))
```

이제 `append_pip`을 이용해 `zero`와 `s`가 제대로 정의된 것인지 확인해 볼 수 있다.
```python
one = s(zero)
three s(zero)

zero_pip = zero(append_pip)
one_pip = one(append_pip)
three_pip = three(append_pip)

zero_pip ("counting..") #=> "counting.."
one_pip  ("counting..") #=> "counting.. pip"
three_pip("counting..") #=> "counting.. pip pip pip"
```

하지만 답이 맞는지 확인할 때마다 pip 갯수를 확인하는건 분명 지치는 일이다. 대신에 처치식 자연수를 python의 `int`형으로 바꿔주는 도우미 함수를 정의하자.
```python
def c2n(n):
  return n(lambda z: z+1, 0)
```
_이러한 도우미 함수들은 예외적으로 파이썬 기능 사용 제한을 완화해서 사용한다._

c2n에다가 one, two, three를 넣어보면 각각 1, 2, 3을 반환한다.
```python
c2n(zero)     #=> 0
c2n(one)      #=> 1
c2n(s(three)) #=> 4
c2n(s(s(s(s(s(s(s(s(s(s(s(zero)))))))))))) #=> 11
```

이제 필요한 건 모두 갖춰졌다. 처치식 자연수에 사칙연산?에 해당하는 각각의 함수를 정의하라.
```
add  :=
mult :=
exp  :=
```

그리고 번역하라.
```python
def add(n, m):
  pass

def mult(n, m):
  pass

def exp(n, m):
  pass
```

아쉽게도 뺄셈은 아직 정의할 수 없다. 결과값이 음수가 되는 경우는 자연수로 표기할 수 없기 때문이다. [3] 뺄셈의 정의는 정수를 정의한 뒤로 남겨두고, 마지막으로 자연수 n을 받아서 처치식 자연수를 반환하는 컨버터를 만들어보자. 이 함수는 도우미 함수이니 람다식으로 환원될 필요도 없고 그럴 수도 없다.

```python
def n2c(n):
  pass
```

----------
[1]: 자연수를 '함수의 반복적용'으로 정의한다는 것이 무슨 뜻일까. "자연수는 함수의 인자가 되는 것이지 함수 자체가 자연수가 될 수는 없지 않은가" 하고 생각하고 있을지도 모르겠다. 대상이 어떻게 표현/정의되었든 자연수라는 의미를 부여하는 것은 대상의 조작규칙이다. 처치식 자연수 정의가 교환법칙 결합법칙 등 자연수의 기본적인 성질을 만족하고 자연수에 행할 수 있는 조작규칙들이 람다대수에도 존재한다면 그것을 자연수라고 부름에 어려울 것이 없다. 설령 그것이 함수일지라도.
[2]: 자연수를 0과 '다음 수'(S)로 정의하는 공리계, 수학자 Giuseppe Peano가 제안했다. 0, 1, 2, 3을 페아노 공리계에서는 0, S(0), S(S(0)), S(S(S(0)))이라고 쓴다. 이렇게 하면 '다음 수'의 개념을 이용해서 수학적 귀납법을 사용할 수 있어 매우 편리하다.
[3]: 사실 정의할 수는 있다. 결과값이 음수가 된다면 그냥 0을 반환하는 것이다. 이 구현은 Recursion 챕터에서 다룬다.

### 불리언

람다식으로 데이터 스트럭처를 표현하는것은 주로 그 대상의 사용을 함수로써 나타내는 경우가 많다. 불리언 타입은 어디에 사용할까? 단순히 두 가지 상태를 나타내기 위해서라면 enum 타입 내지는 정수 (0 또는 1)을 사용하면 된다. 오직 불리언만 가능하고 불리언의 목적이기도 한 작업은 if-else의 브랜칭이다. if의 조건절에는 꼭 불리언 표현식이 들어가야 한다. 파이썬에서는 리스트나 해쉬따위를 조건절에 사용할수 있지만 그저 파이썬이 isEmpty?를 대신 호출해주는것에 불과하다. 브랜칭에 정수를 사용하는 C나 어셈블리에서도 결국은 레지스터의 isZero?를 검사한 후 점프를 한다. 브랜칭을 위해서는 근본적으로 불리언이 필요하다.

그렇다면 브랜칭을 함수로 어떻게 나타낼까. 부작용이 없는 연산만 사용한다면 if-else 구문은 삼항연산자를 사용하는것과 같다. 삼항 연산자는 람다식으로 이렇게 표현할 수 있다.
true  := λx. λy. x
false := λx. λy. y
불리언 값은 인자 2개를 받는 함수인데 True는 첫번째 인자를, False는 두 번째 인자를 반환한다. x가 불리언 타입이라고 한다면 x a b 는 x가 true일때 a, false일때 b가 된다.

파이썬 코드로 작성하면 다음과 같다.
```python
def true(x, y):
  return x

def false(x, y):
  return y
```

테스트하는데 도움이 될 법한 도우미 함수도 정의하자.
```python
# 처치식 불리언을 파이썬 불리언으로 변환한다.
def c2b(b):
  return b(True,False)

def b2s(b):
  if b:
    return "T"
  else:
    return "F"

# 주어진 unary 함수의 진리표를 출력한다.
def check_b(f):
  print(f'T: {b2s(f(true))}')
  print(f'F: {b2s(f(false))}')

# 주어진 binary 함수의 진리표를 출력한다.
def check_bb(f):
  print(f'T T: {b2s(f(true, true))}')
  print(f'T F: {b2s(f(true, false))}')
  print(f'F T: {b2s(f(false, true))}')
  print(f'F F: {b2s(f(false, false))}')
```

이제 다음의 연산들을 구현하라.
그리고 check_b+ 함수들을 사용해 옳은 답이 나오는지 확인하라.
```python
def neg(b):
  pass

def conj(b1, b2):
  pass

def disj(b1, b2):
  pass

def xand(b1, b2):
  pass

def xorr(b1, b2):
  pass
```

### 다시 자연수 (optional)

앞서 대상의 사용을 함수로써 나타냄으로써 데이터 스트럭쳐를 람다식으로 표현할 수 있다고 언급했다. 그렇다면 자연수의 경우는 어떨까. 자연수의 사용은 반복적용이라고 할 수 있을까? 우리가 아는 자연수는 반복보다는 세는것(counting)에 가깝다. [1]
TODO

----------
[1]: 루비같은 언어에서는 자연수를 반복이라는 의미로 사용하는것을 권장한다. `3.times { puts "pip" }` 이라고 쓰면 블럭을 세 번 실행하게 된다. 아쉽게도 반복적용(iterating)은 아니다.

### 튜플

튜플 혹은 Pair라고 불리는 데이터 구조는 수학에서 순서쌍이라고 번역되는 그것이다. 두 데이터를 묶어서 하나의 데이터처럼 취급할 수 있다. 튜플처럼 단순히 두 쌍을 모아둔것에 무슨 사용이 있을까 싶지만, 잘 생각해보면 튜플의 사용은 '선택'임을 알 수 있다. 튜플을 가지고 무엇인가 하려면 두 원소중에 앞의 것을 쓸 건지(fst) 뒤의 것을 쓸 것인지(snd) 결정해야 하기 때문이다. 이를 염두에 두고 람다식 튜플을 정의해 보자.
```python
# 두 데이터를 받아 튜플을 만든다. constructor의 줄임말이다.
def con(x, y):
  pass

# 튜플을 받아 앞의 원소를 리턴한다. first의 줄임말이다.
def fst(t):
  pass

# 튜플을 받아 뒤의 원소를 리턴한다. second의 줄임말이다.
def snd(t):
  pass
```

다음 함수를 사용하면 람다식 튜플을 [11] 파이썬 튜플로 변환할 수 있다.
```python
def c2p(p):
  return fst(p), snd(p)
```

본인의 구현이 아래의 테스트를 통화하는지 확인하라.
```python
c2p(con(1,3)) #=> (1, 3)
pair = con(one,three)
c2n(fst(pair)) #=> 1
c2n(snd(pair)) #=> 3
```

----------
[11]: 계속 '처치식'이라는 표현을 쓰다가 람다식으로 바꾸었는데, 자연수와 불리언을 제외하고는 처치가 직접 정의했는지 (본인은) 모르기 때문이다. 표현만 다르고 같은 의미이다. 헷갈리지 말자.

### 정수

현대 수학에서는 정수를 자연수의 페어(튜플)로 정의한다. 임의의 자연수 a, b에 대해서 튜플 (a, b)는 (a - b)인 정수를 표현한다. 예를 들어 두 튜플 (3, 4)와 (5, 6)는 모두 우리가 평소에 -1이라고 쓰는 정수를 나타낸다. [12] 이렇게 했을 때 덧셈과 뺄셈은 이렇게 정의된다.
```
(a, b) + (c, d) = (a+c, b+d)
(a, b) - (c, d) = (a+d, b+c)
```
a,b,c,d가 두 자연수임을 기억하라. 덧셈을 해도, 뺄셈을 해도 튜플 안의 숫자는 계속 커지기만 한다. 하지만 두 원소의 차는 우리가 예상하는 값을 가지게 된다.
```
(3, 4) + (8, 1) = (11, 5)
( -1 ) + (  7 ) = (  6  )

(3, 4) - (8, 1) = (4, 12)
( -1 ) - (  7 ) = ( - 8 )
```

이런 구상을 람다식으로 나타내어보자. 앞서 정의한 튜플과 자연수를 이용하면 어렵지 않게 정의할 수 있다.
```python
def add_i(i, j):
  pass

def minus_i(i, j):
  pass
```
그리고 어떻게 하는지 설명은 안했지만 곱셈도 정의해보자. 조금만 고민해보면 그리 어렵지 않다.
```python
def mult_i(i, j):
  pass
```

아래의 도우미 함수들을 이용해 구현을 테스트 해 보라.
```python
# 람다식 정수를 파이썬 정수로 바꾼다.
def c2i(i):
    return c2n(fst(i)) - c2n(snd(i))

# 처치식 자연수를 람다식 정수로 바꾼다.
def n2i(n):
    return con(n, zero)

n_one_ = minus(n2i(zero), n2i(one))
n_one = con(two, three)
n_two = add_i(n_one_, n_one)
n_three = add_i(n_one, n_two)
n_six = mult_i(n_three, n2i(two))

c2i(n_one_) #=> -1
c2i(n_one)  #=> -1
c2i(n_two)  #=> -2
c2i(n_six)  #=> -6
```

exp와 div는 아직 정의할 수 없다. 결과값이 유리수가 나올 수 있기 때문이다. 유리수도 정수와 유사한 방법으로 (정수의 튜플을 쓰면 된다) 정의할 수 있지만, 그걸 람다식으로 직접 구현하는것은 머리보다는 손이 힘든 작업일 뿐이다. 그래서 본 챌린지에서는 하지 않는다.

유리수를 넘어 무리수는 ('실수에서 유리수가 아닌 수'라고 정의하는게 아니라) 극한을 사용하여 정의한다. 하지만 극한을 사용하기 위해서는  ∀이나 ∃뿐만 아니라 크기비교가 필요하기 때문에 아직은 할 수 없다.

----------
[12]: 다시 말하지만 의미는 실제로 어떻게 생겼는지와 관계없이 조작규칙에 의해 부여되는 것이다. 튜플의 조작규칙에 의해 (3, 4)와 (5, 6)이 동일하게 취급된다면 적힌 기호(숫자)가 틀린것은 상관이 없다.

### 리스트

이제 비로소 데이터 스트럭쳐다운 뭔가를 정의할 차례다. 리스트란 c에서의 어레이와 비슷한 쓰임새를 가진 데이터이다. 순서대로 늘어선 데이터들을 묶어서 취급한다. 어레이는 c언어에선 연속된 메모리, 자바에서는 연속된 레퍼런스로 구현되지만 람다대수나 함수형 프로그래밍 언어에서는 그렇게 할 수가 없다. 원소 갯수가 정해져있다면 튜플처럼 구현하면 되지만 (트리플? 쿼드플?) 리스트는 길이가 정해져 있지 않다. 임의 갯수의 원소를 순서로 담을 수 있다는것이 리스트의 의의니까 말이다.

리스트를 정의하는 방법은 한가지가 아니다. 마치 자연수가 그러했던 것처럼 리스트의 사용을 무엇으로 보는가에 따라 다른 정의를 만들 수 있다. 그중에서 가장 보편적으로 합의된 리스트의 사용은 'fold'이다. fold란 리스트의 모든 원소를 차곡차곡 겹쳐(접어)서 하나의 값으로 만드는 작업을 의미한다. 유명한 병렬컴퓨팅 프레임워크인 하둡의 MapReduce에서 reduce가 바로 fold이다. 파이썬에서는 reduce라고 불린다.

fold의 가장 간단한 예시는 덧셈이다. 예시를 설명하기 위해 잠시 파이썬 리스트를 이용하겠다.
```python
from functools import reduce
xs = [1,2,3,4]
reduce(lambda a,b: a+b, xs, 100) #=> 110
```
위의 reduce는 다음을 계산한다.
```python
(((100 + 1) + 2) + 3) + 4 #=> 110
```

reduce는 맨 처음 값과 리스트의 첫 값을 계산하고, 그 결과를 리스트의 두번째 값과 계산하고... 이를 리스트 끝까지 반복한 후 결과를 리턴한다. 사실 fold에는 두 가지 종류가 있는데 reduce처럼 리스트의 왼쪽부터 계산하는것을 foldl (left) 오른쪽부터 계산하는것을 foldr (right)라고 한다. 덧셈이나 곱셈같은 commutative한 연산에서는 차이가 없지만 나눗셈처럼 nocommutative한 연산에서는 다른 값을 낸다.
```python
# foldl과 foldr이 아직 정의되지 않았으므로 아직 실행할 수는 없다.
foldl(lambda acc,x: acc/x, [1,2,3,4], 120) #=> 5
foldr(lambda x,acc: x/acc, [1,2,3,4], 120) #=> 45
```
위의 예제가 어떻게 작동하는지 직접 계산해보자. foldr은 주어진 함수에게 인수를 반대로 준다는 점에 유의하라. (acc에 계산값이, x에 리스트의 원소가 주어진다)

fold에서 계산 결과 값 (맨 처음에 주는 seed값, 매번 인자로 준 함수가 리턴하는 값, 그리고 결과적으로 fold가 리턴하는 값)을 어큐뮬레이터(accumulator)라고 부른다. 지금까지의 계산 값을 축적하고 있기 때문이다. 그래서 위 예제 람다함수의 인자에 acc라는 이름을 붙였다.

fold에 익숙하지 않은 사람은 람다식 리스트를 구현하기 전에 fold를 제대로 이해하는것이 중요하다. foldl을 (반복문을 쓰지 말고) 재귀함수로 구현해보자. 인수로 주어진 리스트는 마음대로 mutation-safe 하다고 가정하라. (함수 안에서 값을 수정해도 호출부에서 신경쓰지 않는다)

```python
def foldl(f, ls, seed):
  pass

foldl(lambda a,b: b/a, [1,2,3,4], 120) #=> 5
foldl(lambda a,b: b/a, [4,3,2,1], 120) #=> 45
```

foldl만 사용했는데도 앞의 foldr 예시와 같은 값이 나온다. 사실 두 함수는 어느 하나도 다른 하나를 구현할 수 있다. 우리는 foldl을 먼저 구현했으니 그걸 이용해 foldr을 구현해보라 (가능함을 확인하는 것 뿐이니 효율성에 신경쓰지 않아도 된다)
```python
def foldr(f, ls, seed):
  pass
foldr(lambda a,b: b/a, [1,2,3,4], 120) #=> 320
```

이제 본론으로 돌아가서 리스트를 구현해보자. 리스트는 두 가지 방법으로 만들 수 있다. 1. 그냥 빈 리스트이거나 2. 다른 리스트와 원소 하나를 받아서 새 리스트를 만든거나. 백마디 말보다 한 줄 코드가 이해하기 쉽다고, 파이썬 코드로 아이디어를 표현하면 이렇게 된다.
```python
def empty_p():
  return []

# constructor_python의 약자이다
def cons_p(x, ls):
  return [x] + ls
```
이 함수들을 써서 `[3,1,2]`를 나타내면 이렇게 된다.
```python
cons_p(3, cons_p(1, cons_p(2, emtpy_p))) #=> [3,1,2]
```

이제 필요한 정보는 다 있다. 아래의 테스트를 통과하도록 람다식 리스트를 정의해보자.
```python
def empty():
  pass

def cons(x, ls):
  pass

sample_list1 = cons(1, cons(2, cons(3, empty)))
sample_list1(lambda x,y: x+y, 0) #=> 6

sample_list2 = cons("aaa", cons("bbb", empty))
sample_list2(lambda s1,s2: s2 + s1, "ccc") #=> "bbbaaaccc"

sample_list3 = cons(one, cons(two, cons(three, empty)))
c2n(sample_list3(add, zero)) #=> 6
c2n(sample_list3(mult, six)) #=> 36
```

리스트의 사용을 fold로 정의한데는 그만한 이유가 있다. 우리가 리스트에 수행하는 거의 모든 작업들은 fold를 이용해 구현될 수 있기 때문이다. 그런 작업들을 나열하자면 수없이 많지만 여기서는 map, append, reverse, zip, filter만 구현해보자.

아래의 도우미 함수들이 코드를 테스트하는데 유용할 것이다.
```python
def push_back(ls, x):
  ls.append(x)
  return ls

# 람다식 리스트를 파이썬 리스트로 바꾼다.
def c2l(ls):
  return ls(push_back, [])

# 처치식 정수들로만 이루어진 리스트를 파이썬 데이터로 변환해서 화면에 출력해준다.
def printNatList(ls):
  print(list(map(c2n, c2l(ls))))

print(c2l(cons(1, cons(2, empty)))) # [1, 2]
ls1 = cons(one, cons(three, cons(two, empty)))
printNatList(ls1) # [1,3,2]
```

#### length

리스트의 길이를 리턴한다. 아주 대표적인 polymorphic 리스트 오퍼레이션 중 하나인데, 리스트안에 무엇이 담겨있던지 (정수든, 함수든..) 상관없이 작동하기 때문이다. 데이터를 신경쓰지 않는다는 점에 착안하면 간단히 구현할 수 있다. 아 물론 처치식 자연수를 리턴해야 한다.

```python
def length(ls):
  pass

c2n(length(ls1)) #=> 2
c2n(length(sample_list3)) #=> 3
```

#### map

MapReduce의 map이다. 함수와 리스트를 받아 각 리스트의 원소에 적용한 새 리스트를 리턴해준다. 백문이 불여일코드, 파이썬에 이미 같은 이름과 기능의 함수가 있다.
```python
map(lambda n: n//2 if n%2==0 else 3*n+1, [4, 3, 1, 2])
  #=> [2, 10, 4, 1]
```

구현하라.
```python
# 파이썬의 빌트인 map과 충돌을 피하기 위해 언더스코어를 붙였다.
def map_(f, ls):
  pass

ls2 = cons(four, cons(three, cons(one, cons(two, empty))))
ls3 = map(lambda n: add(one,mult(three,n)), ls2)
printNatList(ls3) # [13, 10, 4, 7]
```

#### append

두 리스트를 이어붙이는 함수이다. 파이썬에서 리스트에 대해 오버로딩된 + 연산자와 같다. 구현하라.

```python
def append(xs, ys):
  pass

ls4 = cons(two, cons(three, cons(one, empty)))
ls5 = append(ls1, ls4)
printNatList(ls5) # [1, 3, 2, 2, 3, 1]
```

#### reverse

리스트를 뒤집어주는 함수다. 파이썬에는 리스트의 메소드로 같은 함수가 있다. 리스트의 길이를 알아낸 다음 뒤에서부터 인덱싱하면 손쉽게 구현할 수 있지만 우리는 아직 인덱싱을 할 수 없다. 사실 램덤액세스가 가능한 c 어레이와 다르게 이런 리스트는 인덱싱이 O(n)이기 때문에 그렇게 좋은 정의는 아니다. 여기서는 어큐뮬레이터로 리스트를 사용하면 깔끔하게 정의할 수 있다.

```python
def reverse(ls):
  pass

printNatList(reverse(ls4)) # [1, 3, 2]
```

#### zip

두 리스트를 결합해 튜플의 리스트를 리턴한다. 파이썬에 같은 함수가 있다. 지면 절약을 위해 파이썬 함수를 보고 동작을 유추하는것으로 하자. reverse와 비슷한 기법으로 해결할 수 있다.
```python
def zip_(xs, ys):
  pass

c2l(map_(
  lambda tup: c2n(fst(tup)), c2n(snd(tup))
, zip_(ls4, ls5))) #=> [(2,1), (3,3), (1,2)]
```

#### filter

filter는 리스트에서 조건에 맞지 않는 원소들을 골라내는 함수이다. 조건은 인자로 주는 함수로 넘겨준다. 마찬가지로 파이썬에도 같은 함수가 있으니 자세한 설명은 파이썬 레퍼런스를 보자.

```python
def filter_(f, ls):
  pass
```

아쉽게도 filter는 아직 테스트 해볼 수 없다. 우리가 불리언을 정의하기는 했지만 불리언을 리턴할 수 있는 비교함수는 하나도 안 만들었기 때문이다. 없는대로 예제를 만들면 이정도가 최선이다.
```python
ls7 = cons(con(true, one), cons(con(false, two), cons(con(true, three), empty)))
print(NatList(map(snd, filter(fst, ls7))) # [1, 3]
```
### 다시 리스트

리스트의 사용을 튜플과 마찬가지로 '선택'으로 생각한다면 튜플만을 이용해 정의할 수도 있다. 보통 함수형 언어에서는 이렇게 정의한다.
TODO

### 재귀

minus
head
tail

## 주절주절
본 문서를 작성하는데 이런 것들이 영향을 끼쳤다.
* Software Foundations Vol.1 - Logical Foundations
  literate programming을 비롯해 전체적인 글의 분위기에 영향을 받았다.
  초기 첼린지 구상이 이 책의 연습문제에서 시작되었다.
* Structure and Interpretation of Computer Program 번역서
  거의 모든 기술용어들을 우리말로 순화한 역자의 열정이 나도 용어들을 한글로 번역해서 쓰도록 했다.
