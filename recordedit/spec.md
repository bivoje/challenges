레코드 에디터
============

### 프롤로그

* 본 글은 2016년을 배경으로 작성되었습니다.

대한민국의 일류 과학기술원인 지스트에는 매년 미래창조과학부(현 과학기술정보통신부) 장관이 시찰을 하러온다. 어짜피 지스트가 훌륭한건 모두 아는 사실이므로 거의 형식적인 절차지만 그래도 지스트측에서는 신경을 쓸 수밖에 없다. 매해 그날이 오면 지스트는 좀처럼 작동하는걸 보기 힘든 분수를 틀고, 운동회라는 이름으로 학부/대학원생들을 동원해 최대한 활발한 캠퍼스를 연출한다.

그런 노력 중에서도 가장 공을 들이는것은 학부생 대표 2,000명의 '장관님께 감사하는 마음을 담은 10,000자 내외 수필' 전달이다. 5년 전까지만 해도 학부생과 대학원생이 모두 참가하는 행사였으나, 대학원생들이 연구실의 가구처럼 24/7 쉬지않고 일할 수 있도고 배려하자는 장관의 제안으로 학부생만의 행사가 되었다. 하지만 그로 인해 2,000명 분의 글을 충당하지 못할것을 우려한 지스트 총장은 데이터베이스에 가상의 학생 1,000여명을 추가해 한 학생당 2명분의 글을 제출하도록 했다.

도합 2.0E10자에 달하는 전달된 글들을 정말로 장관이 읽어보는지는 알 수 없으나, 한 편의 글이라도 이상한 내용이 들어갔다간 예산삭감과 같은 무시무시한 일이 벌어질 수도 있기에 모든 글은 지스트 학사지원팀의 검열을 거친다. 실례로 검열이 없던 시절, 과제가 바쁘다는 이유로 "ㅗ"와 "김정은 수령님 만세"를 적은 글 두편을 제출한 *종명 학생이 남산 코렁탕을 맛보고는 다시는 연구를 할 수 없는 몸이 된것은 잘 알려진 이야기다.

학생들이 작성한 수필들이 제출되면 학사지원팀에서는 모든 행정업무를 멈추고 글의 검열을 시작한다. 검열은 세세한 표현부터 글의 내용까지 모든 면에서 행해지는데, 요 근래엔 주로 창조경제에 대한 부정적 의견을 걸러내고 있다. 만약 글에서 부절적한 사상이 검출된다면 #수정요함 이라는 태그를 붙여둔다. 그 후, 글들은 글쓰기 담당 교수님들께 전달되어 부적절한 내용을 수정받게 된다. 글의 수정은 작성한 학생이 하는것이 원칙이지만 때마침 시험기간인 학생들에게 다시 부탁할수는 없어 그냥 교수님들께서 일괄 수정을 하신다. 그래서 시험기간의 글쓰기 교수님들은 인당 수백건에 달하는 글을 교정하는 업무를 떠맡으시게 된다.

알레프 교수님은 매년 수필의 교정작업을 하시는 분들 중 한명이다. 프로그래밍을 할 줄 아시어 특히나 멋진 알레프 교수님은 수정된 글들을 관리하는것이 매우 피곤하다고 생각하던 참이다. 게다가 매우 빈번히, 본인 학번과 (총장이 추가한) 가상 학번을 헷갈리는 학생들이 번호를 잘못 등록해 놓고는 교수님께 정정해달라고 메일을 하여 안그래도 헷갈리는 관리를 더욱 끔찍하게 만든다. 그래서 이번 해에는 여러분에게 글의 수정을 관리할 수 있는 프로그램을 작성해 달라고 부탁할 참이다. 여러분은 이번 학기 심각한 우울증으로 교수님의 수업에 결석을 밥먹듯이 했기 때문에 F를 받기로 되어있었다. 이번 학기에도 F를 받으면 국가장학금이 끊겨버리기 때문에 더 이상 PC방의 방탕한 생활을 할 수가 없다. 하스켈로 프로그래밍을 할 수 있는 완정 짱짱 멋진 알레프 교수님은 여러분이 프로그램을 작성해 온다면 특별히 이번학기 성적 산출에에 출결을 반영하지 않겠다고 하신다. 별다른 선택지가 없는 여러분은 내일까지 프로그램을 짜오겠다고 대답했다.

학사지원팀에서는 글들을 (문서번호(id), 학번(stid), 문서내용(doc), 수정필요(improper))의 배열로 정리한다. 이 배열의 각 항목을 '레코드'라고 부르자. 현재는 RDBM으로 관리되고있지만 나중에 어떻게 바뀔지 모르니 미래를 내다보는 현명한 프로그래머인 알레프 교수님은 데이터 접근을 추상화시키기로 했다. 여러분이 졸업한 후에도 학사지원팀의 변덕에 맞춰 데이터 접근 인터페이스를 직접 구현할 수 있도록 말이다. 그러니 인터페이스는 구현되었다고 가정하고 코드를 작성하면 된다.

교수님께서는 여러분에게 다음과 같은 적힌 요구사항이 적힌 껌종이를 주셨다. 글씨가 너무 작아서 실험실 현미경으로 봐야 했지만 어쨌든 알아볼 수는 있었다. 어째서인지 본인을 3인칭화 하고 있지만 알게뭐야

### 껌종이

  - 아무 언어나 사용해도 된다. 훌륭한 폴리글랏 프로그래머인 알레프 교수님(나야 나)은 네가 짠 코드로부터 사용한 언어를 배워서 바로 사용할 수 있다.

  - 데이터 접근은 다음과 같은 인터페이스로 추상화시킨다.
    for int id, stid; string doc; bool improper;
    * GET (id) -> (stid, doc, improper)
    * SET (id, (stid, doc, improper)
    * COUNT -> int
    네가 어떤 자료형을 사용하건, 어떻게 인터페이스르 이용하건 (클래스 인터페이스로 쓰든, 함수형 스타일로 쓰든) 똑똑하고 유능한 프로그래머인 알레프 교수님(나라구)은 적당히 그에 맞춰서 구현할 수 있다.

  - 데이터 접근 인터페이스에 대해 다음을 가정하라
    * id는 [0, COUNT) 범위 안에 있다. 범위 안의 모든 id는 유효하다.
    * 교수가 프로그램 사용하는 동안은 데이터에 lock이 걸린다. 해당 시간에 교수 외에 데이터를 수정하는 사람은 없다.
    * GET, SET은 굉장히 느린 작업이다. C에서 배열 접근하듯이 사용했다간 매 작업마다 모래시계 마우스 포인터를 구경해야 할 것이다.

  - 기민하게 작동했으면 좋겠다
    * id=3인 레코드를 수정하기 위해서 관심도 없는 id = 0 ~ 2000인 다른 레코드를 로드하는걸 기다려 줄 시간은 없다.
    * 교수님의 컴퓨터는 인텔 386 cpu에서 돌아가기 때문에 학생들의 수필을 비교하는것도 너-무 오래걸린다. 감안하도록.

  - 수정을 커밋하는걸 미뤄둘 수 있으면 좋겠다
    요즘 웬만한 에디터는 다 지원하는 기능이라구. 메모장으로 문서를 열어서 수정하면 바로바로 저장된 문서가 바뀌나? 아니잖아! 저장을 눌렀을 때 비로소 저장되잖아. 나는 그게 하고싶어. 내가 i번째 레코드를 수정했다고 해서 바로 SET을 호출하는게 아니라 i번째 레코드를 저장?하라고 했을때 비로소 SET을 호출하는거 말야.

  - 그리고 당연히 내가 뭘 수정했는지 알아야 할 거 아니야. 저장을 미뤄두고 한창 수정하다가 뭘 수정했는지 기억을 못해서 빠트리고 프로그램을 꺼버리면 어떠해?

  - 포토샵이 발명된 이후로 수많은 그림쟁이들이 연필을 내려두고 G펜을 들었다고 하지. 요즘 일러스트 업계에서는 수작업으로 그리는 사람이 명물취급을 받는다구. 물론 그런 사람들이 능률이 좋은가 하면 그게 또 아니야. 새로운 기술을 받아들이지 못하고 전통을 고수하다가 사라져버린 장인이 얼마나 많겠어? 그런 사람들은 컴퓨터를 써서 그리는 사람들에 비해 작업속도가 느려서 점점 책상이 사무실 구석으로 밀려나다가 어느순간 정신차리고 보면 무직이 되어있고 그래. 내 친구가 그랬다는건 아니고 어 뭐냐.. 무슨 말을 하려고 했더라

  - Emacs를 쓰는 놈팽이들은 엿ㅇ나 먹으라 그래. 프로그래머를 위해 만든 에디터라고? 다른 프로그래머들은 새끼손까락 옆에 새끼새끼손가락이 달렸다나? 컨트롤 키를 그렇게 많이 눌러서는 내 사랑스런 새키손가락이 남아나질 않겠어. 나느 뼜속부터 vim파야. 물논 익숙해지기까진 좀 걸리지만 익숙해진 다음에는 빛과 같은 속도로 문서를 수정할 수 있다고. 요즘들어서는 nano라는 늅들을 위한 그켬 에디터도 나오던데 그거야말로 하프라이프 팬한테 포트나이트 하라는 꼴이지. 배포판에대가 그딴 에디터를 vim대신 기본으로 넣는 캐노니컬사는 머리가 어떻게 된 게 틀림없다구. 그래서 나는 멍청학 학생들이 쓴 냄새나는 수필을 수정할때 vim을 써야겠어. 다른건 몰라도 그것만은 좀 신경을 써 줘

  - 아 맞어 그러니까 되돌리기랑 다시하기를 지원하라 이거지. 수작업 일러스트레이터가 포토샵 이러스트레이터를 이길 수 없는 결정적ㅇ 이유기 여기에 있어. 종이에 그림을 그리면 CTRL-Z를 누룰수가 없거던. 그리고 당연히 되돌리기를 해서 저장한 직후로 돌아가면 수정한 사실이 안보여야겠지?


### 실험실

껌종이는 밑으로 갈수록 두서없이 작성되어 있었다. 중간중간 물방울이 떨어져 펜이 번진 것으로 보아 공원 벤치에서 작성하다가 비가 오기 시작해, 서두르다가 그렇게 된 것은 아닐까. 아니, 펜의 성분을 크로마토그래피로 분석해보니 모나미 유성펜인것으로 보아 빗물은 아니다. 아마 쓰면서 술이라도 들이키다가 흘렸을것이다.

여러분의 일은 이 요구사항을 토대로 사용성이 좋은 프로그램을 작성하는 것이다. 사용성이 좋아야 하는 이유는, 교수님이 프로그램을 쓰시다가 빡이 돌면 여러분의 성적에 심각하게 않좋은 영향이 있을 것이기 때문이다. 그렇게 되면 PC토랑에서 컵라면을 시켜먹으며 포트나이트를 하는 사치를 부릴수가 없게된다. 모쪼록 잘 되도록 해 보자.

__본 챌린지의 두 가지 목표를 위시하며 설계되었다. 첫 번째 목표는 주어진 문제 상황에 대해서 어떻게하면 사용성 높은 프로그램을 만들지 고민하고, 자신의 결정을 토대로 구현하도록 하는 것. 두번째 목표는 및의 명세에서 정의할 특정 기능들을 직접 구현해 보는 것. 명세를 보지 않고 본인이 구상한 프로그램이 명세에서 정의하는 기능들을 포함하고 있다면 최선이겠지만 항상 그렇게 형편좋게 돌아가진 않는다. 게다가 프로그램을 처음부터 구상하고 구현 중에 계속 수정하는것은 꽤나 시간이 많이걸린다. 그래서 바쁜 현대인들을 위해 첫 번째 목표를 포기하고 두번째 목표만을 취하는 분기가 있다. 분기를 선택하지 않으면 모든걸 직접 하는 진엔딩, 분기를 선택하면 구현만 하는 서브엔딩을 보게 된다.__

### 분기

여러분은 밤을 꼬박 지새우며 어떤 모양의 프로그램을 짜야 할 지 고민했지만 아무 성과가 없었다. 결국 연구실에서 자고있던 알레프 교수님의 조교에게 첨단스시를 약속하며 프로그램 명세서를 받아낼 수 있었다. 교수님의 수발이 되어 온갖 업무를 처리하는 조교에게 어떤 형태의 프로그램이 교수님을 만족시킬지 생각하는것은 채 10분도 걸리지 않는 일이었다. 조교는 멋들어진 latex 포맷으로 명세서를 전달.. 했으나 latex를 어떻게 읽는지 모르는 불쌍한 여러분은 온라인 latex -> markdown 변환기를 사용해 마크다운 형식으로 바꿔서 읽었다.


### 명세

터미널 프로그램이다.

#### 스크린샷

```
$ ./editor
==================================
Welcome! Prof. ℵ
==================================

    8|   20165382   c72e3aa87b
 >  9|   20171025 O 5f5c07e32a
   10|   20184875 O e0a5f7523c

]] j

    9|   20171025 O 5f5c07e32a
 > 10|   20184875 O e0a5f7523c
   11|   20182289   53cfe7205a

jump 9 10]] h

file contents=================
간장공장 공장장은 강공장장이고
공공장 공장장은 장공장장이다
내가 그린 기린 그림은 잘 그린 기린 그림이고
네가 그린 기린 그림은 잘 못 그린 기린 그림이다
중앙청 창살은 쌍창살이고
...

jump 9 10]] e
# vim이 열렸다가 닫힘

    9|   20171025 O 5f5c07e32a
 > 10| * 20184875 O f2c5d88374
   11|   20182289   53cfe7205a

jump 9 10, edit e0a f2c]] t

    9|   20171025 O 5f5c07e32a
 > 10| * 20184875   f2c5d88374
   11|   20182289   53cfe7205a

edit e0a f2c, toggle O X]] w

    9|   20171025 O 5f5c07e32a
 > 10|   20184875   f2c5d88374
   11|   20182289   53cfe7205a

edit e0a f2c, toggle O X]] u

    9|   20171025 O 5f5c07e32a
 > 10| * 20184875 O f2c5d88374
   11|   20182289   53cfe7205a

jump 9 10, edit e0a f2c]] q
there are unsaved changes, Are you sure you want to quit? (y/N) Y
good bye
$
```

#### UI

레코드가 출력되고 사용자로부터 명령을 입력받는 프롬프트가 나타난다. 명령이 입력되면 그에 따라 처리를 하고 필요에 따라 레코드를 출력하고 프롬프트 띄우기를 반복한다.

레코드의 출력은 현재위치(커서)를 포함해 위 x개, 아래 y개의 레코드를 각 줄에 표시한다. 각 레코드는 (id, modified?, stid, improper?, file)의 순으로 저장된다. 

#### 명령어 집합

  [sS] [hl] [jJkKgG] [nN] [ab] [uU] w ! ?

  * s [%n]
  두 학생의 작문을 바꾼다.

  * S [%n]
  swap yield with nth' logs' yield
  positive n, is default to right before one

  * h
  show yield contents head
  not put in history

  * l
  show yield contents with 'less' shell command
  not put in history

  * j
  goto next log

  * J
  goto next unshown log (+= show_below + 1)

  * k
  goto previous log

  * K
  goto previous unshown log (+= show_above + 1)

  * g
  goto top log

  * G
  goto bottom log

  * n
  goto next log with an yield

  * N
  goto latest log with an yield

  * a %n
  set 'show_above' value to positive integer n

  * b %n
  set 'show_below' value to positive integer n

  * u
  undo last command
  not put in history

  * U
  redo last command
  not put in history

  * w
  write to db, update changes
  not pushed to history

  * !
  set stopper (anchor) in history. prevents instr squashing.
  it will be added nomarly but subsequent instr will squash
  :anchor as if it's capriol. so to say, it's one-time-use.
  :anchor is squshed with another :anchor.

  * ?
  help! show this message
  not put in history
HEREDOC




























